[
  {
    "objectID": "toolstutorials.html",
    "href": "toolstutorials.html",
    "title": "Tools und Tutorials",
    "section": "",
    "text": "How to: Computerbasierte Texterkennung\n\n\n\n\n\n\n\nDaten explorieren (und visualisieren) mit Tableau Public\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "tableaupublic.html",
    "href": "tableaupublic.html",
    "title": "Daten explorieren (und visualisieren) mit Tableau Public",
    "section": "",
    "text": "In diesem Tutorial möchten wir das Tool Tableau Public für Datenanalyse und Datenvisualisierung vorstellen. Hierzu geben wir einen kurzen Überblick über die Möglichkeiten dieses Tools und wie es bei der Arbeit mit Daten helfen kann."
  },
  {
    "objectID": "tableaupublic.html#was-ist-tableau",
    "href": "tableaupublic.html#was-ist-tableau",
    "title": "Daten explorieren (und visualisieren) mit Tableau Public",
    "section": "Was ist Tableau?",
    "text": "Was ist Tableau?\n\nFunktion: Es handelt sich um die browserbasierte kostenlose Version des BI-Tools Tableau. Diese öffentliche Version ermöglicht, Datensätze hochzuladen, sie zu analysieren, zu visualisieren, Dashboards zu erstellen und sie auf einer persönlichen Seite zu veröffentlichen oder in verschiedenen Formaten herunterzuladen.\n\nKostenlose Version, Registrierung erforderlich\n\nKeine Installation erforderlich, für Studierende und Lehrende kann eine einjährige Pro-Lizenz kostenlos erworben werden\n\nKein Programmierwissen erforderlich\n\nBesonders interessant für die Datenexploration: Im Vergleich zu anderen Visualisierungstools wie RAWGraphs oder DataWrapper ermöglicht das Tool, Datenanalysen direkt durchzuführen, ohne schon im Voraus perfekte Pivot-Tabellen mit den Werten erstellt haben zu müssen."
  },
  {
    "objectID": "tableaupublic.html#wie-funktioniert-tableau-public",
    "href": "tableaupublic.html#wie-funktioniert-tableau-public",
    "title": "Daten explorieren (und visualisieren) mit Tableau Public",
    "section": "Wie funktioniert Tableau Public?",
    "text": "Wie funktioniert Tableau Public?\nTableau bietet verschiedene Tutorials, abhängig von Kenntnisstand, und bietet auch ein Forum an, in dem man Fragen stellen und überprüfen kann.\nTableau Einführung"
  },
  {
    "objectID": "tableaupublic.html#hochladen-von-datensätzen",
    "href": "tableaupublic.html#hochladen-von-datensätzen",
    "title": "Daten explorieren (und visualisieren) mit Tableau Public",
    "section": "Hochladen von Datensätzen",
    "text": "Hochladen von Datensätzen\nNachdem wir unser Profil auf Tableau Public erstellt haben, müssen wir auf unser Profil zugreifen und die Kachel “Visualisierung erstellen” wählen, um zur Benutzeroberfläche zu gelangen, die es uns ermöglicht, Daten hochzuladen:\n\n\n\n\n\nWir fangen an mit einem einfachen “Drag and drop” des Datensatzes nach dem Herunterladen.\nWir werden mit dem Datensatz Open Syllabus Movie Ranks arbeiten. In Bezug auf diesen Datensatz wurden bereits einige Visualisierungen mit Tableau produziert, wir werden in diesem Tutorial auch versuchen, eine Visualisierung nachzubilden."
  },
  {
    "objectID": "tableaupublic.html#bearbeiten-des-datenformats",
    "href": "tableaupublic.html#bearbeiten-des-datenformats",
    "title": "Daten explorieren (und visualisieren) mit Tableau Public",
    "section": "Bearbeiten des Datenformats",
    "text": "Bearbeiten des Datenformats\nTableau zeigt eine Vorschau unseres Datensatzes an, wir möchten möglicherweise den Datentyp jeder Spalte anpassen. Dies ist möglich, indem wir auf die angezeigten Spalten klicken und einen neuen Datentyp auswählen. Normalerweise erkennt Tableau die Datentypen ohne Probleme. Wir fahren dann fort, indem wir auf die untere Leiste auf “Sheet” klicken."
  },
  {
    "objectID": "tableaupublic.html#werte-wählen-die-analysiert-und-visualisiert-werden-sollen",
    "href": "tableaupublic.html#werte-wählen-die-analysiert-und-visualisiert-werden-sollen",
    "title": "Daten explorieren (und visualisieren) mit Tableau Public",
    "section": "Werte wählen, die analysiert und visualisiert werden sollen",
    "text": "Werte wählen, die analysiert und visualisiert werden sollen\nZunächst möchten wir erkunden, wie viele Filme in unserem Datensatz in einem bestimmten Jahr veröffentlicht wurden. Wir möchten ein Liniendiagramm erstellen. Wir können unsere Werte von der linken Ecke auf die Balken für Zeilen und Spalten unserer Visualisierung ziehen und ablegen. Zuerst wählen wir Jahr und legen es auf Spalten, als nächstes wählen wir Titel für die Zeilenleiste. Weil wir eine bestimmte Menge sehen wollen, klicken wir mit der rechten Maustaste auf Jahr und wählen Kennzahl &gt; Anzahl.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDas Liniendiagramm kann auch gefiltert werden, falls wir nach bestimmten Filmen in unseren Datensätzen suchen möchten, wie z.B. nach dem Herkunftsland. Der Wert wird per “Drag and Drop” direkt auf das Filterfeld gezogen."
  },
  {
    "objectID": "tableaupublic.html#erstellen-anderer-diagrammtypen-in-sekundenschnelle",
    "href": "tableaupublic.html#erstellen-anderer-diagrammtypen-in-sekundenschnelle",
    "title": "Daten explorieren (und visualisieren) mit Tableau Public",
    "section": "Erstellen anderer Diagrammtypen in Sekundenschnelle",
    "text": "Erstellen anderer Diagrammtypen in Sekundenschnelle\nWir möchten unsere Daten möglicherweise auch auf einer Karte anzeigen. Um dies sehr schnell zu tun, haben wir eine Menüleiste auf der rechten Seite, die bereits Vorschläge für andere Diagrammtypen enthält:\n\n\n\n\n\n\n\n\n\n\nBei Auswahl der Karte gibt uns die Software bereits eine Farbskala für unsere Werte auf einer Weltkarte. Die gleiche Operation können wir wiederholen, indem wir ein Blasendiagramm erstellen, um die verschiedenen Werte für jedes Herkunftsland anzuzeigen:\n\n\n\n\n\nWenn wir Werte auf einen der anderen “Marker” (zweite Menüleiste rechts) ziehen und ablegen (wie Farbe, Detail, Größe usw.), können wir die einzelnen Werte mit verschiedenen Codes anzeigen: wenn wir beispielsweise Land auf die Farbmarke ziehen, zeigt unsere Visualisierung ein farbcodiertes Blasendiagramm an."
  },
  {
    "objectID": "tableaupublic.html#verfeinern-der-visualisierung-und-exportieren-der-diagramme-oder-dashboards",
    "href": "tableaupublic.html#verfeinern-der-visualisierung-und-exportieren-der-diagramme-oder-dashboards",
    "title": "Daten explorieren (und visualisieren) mit Tableau Public",
    "section": "Verfeinern der Visualisierung und Exportieren der Diagramme oder Dashboards",
    "text": "Verfeinern der Visualisierung und Exportieren der Diagramme oder Dashboards\nJede Visualisierung kann durch Hinzufügen eines Titels und weiterer zusätzlicher Informationen oder durch Hervorheben oder Markieren bestimmter Werte usw. vervollständigt werden. Verschiedene Diagramme können innerhalb eines Dashboards gesammelt werden, indem neue Blätter auf der unteren Leiste erstellt werden und die Visualisierung unserem Dashboard hinzugefügt wird. Jede Visualisierung oder jedes Dashboard kann später als PNG oder PowerPoint heruntergeladen werden. Wir können es auch auf unserem Tableau Public-Profil veröffentlichen, um später darauf zuzugreifen und daran zu arbeiten."
  },
  {
    "objectID": "tableaupublic.html#erstellen-des-balkendiagramms-aus-open-syllabus-movie-rank",
    "href": "tableaupublic.html#erstellen-des-balkendiagramms-aus-open-syllabus-movie-rank",
    "title": "Daten explorieren (und visualisieren) mit Tableau Public",
    "section": "Erstellen des Balkendiagramms aus Open Syllabus Movie Rank",
    "text": "Erstellen des Balkendiagramms aus Open Syllabus Movie Rank\nUm die Balkendiagrammvisualisierung des Open Syllabus Movie Rank neu zu erstellen, können wir die Werte “Rang” und “Regisseur” verwenden. Für jeden Regisseur möchten wir die Anzahl der Titel zusammenzählen. Nachdem wir den Wert gezogen und abgelegt haben, klicken wir auf den Regisseur und wählen Summe. Anschließend, um auf dem Balkendiagramm jedes Regisseurs Filme mit einer anderen Farbe anzuzeigen, ziehen wir den Titel per “Drag and Drop” auf die Farbmarke.\n\n\n\n\n\nUm die Größe des Diagramms anzupassen, können wir die Visualisierung in ein Dashboard importieren, indem wir den Cursor an den Rand des Diagramms bewegen und es in die Richtung bewegen, in die wir es vergrößern oder enger machen möchten."
  },
  {
    "objectID": "tableaupublic.html#was-ist-allgemein-bei-der-benutzung-von-tableau-public-zu-beachten",
    "href": "tableaupublic.html#was-ist-allgemein-bei-der-benutzung-von-tableau-public-zu-beachten",
    "title": "Daten explorieren (und visualisieren) mit Tableau Public",
    "section": "Was ist allgemein bei der Benutzung von Tableau Public zu beachten?",
    "text": "Was ist allgemein bei der Benutzung von Tableau Public zu beachten?\n\nDie Daten sollten im CSV- oder Excel-Format vorliegen, damit die Software sie lesen kann. Wir müssen nicht alle Werte im Voraus erstellen, sondern können unsere Analyse direkt im Tool durchführen.\n\nLeere Werte werden als Nullwerte erkannt, man kann sie während der Analyse direkt filtern.\n\nMehr als ein Wert in einer Zelle kann nicht gezählt werden.\n\nEs ist nicht immer klar, wie vorzugehen ist, um dem Diagramm mehr als einen Wert hinzuzufügen, aber normalerweise hilft es, zusätzliche Werte auf die Balken zu ziehen und abzulegen oder direkt auf das Diagramm zu ziehen und abzulegen. Ein Plus ist, dass man mehrere Werte gleichzeitig darstellen kann.\n\nAuf der linken Seite gibt es zusätzliche statistische Methoden im Analysemenü. Es ist beispielsweise möglich, eine Linie hinzuzufügen, die den Durchschnittswert zählt.\n\nWir empfehlen diese zusätzlichen Tutorials anzusehen, um mehr über die Möglichkeiten der Arbeit mit Tableau Public zu erfahren und einen Überblick über bewährte Verfahren zu erhalten:\nCharts-Katalog\nBest Practices\nDie Screenshots wurden von Nicole Braida erstellt. Zuletzt bearbeitet am 09.02.2024"
  },
  {
    "objectID": "mediarep.html",
    "href": "mediarep.html",
    "title": "Datengestützte Analysen mit media/rep/",
    "section": "",
    "text": "Das DiCi-Hub-Projekt hat sich für eine Analyse von medienwissenschaftlichen Daten mit dem Open Access-Repositorium für medienwissenschaftliche Publikationen media/rep/ zusammengetan. Wir haben uns der Frage gewidmet, wie sich bestehende Forschungsinfrastrukturen für datengestützte Analysen nutzen lassen. Konkret gesagt war unser Ziel, die in media/rep/ vorliegenden Publikationen mit ihren zugehörigen Metadaten mithilfe von digitalen Methoden auszuwerten und dadurch fachhistorische Perspektiven der deutschen Medienwissenschaft zu erkunden.\nDie ersten Ergebnisse der Analyse sind nun online in der Zeitschrift für Medienwissenschaft erschienen:\nhttps://zfmedienwissenschaft.de/online/die-vermessung-der-medienwissenschaftlichen-welt\nWir beschreiben darin, wie wir uns ein Textkorpus aus den in media/rep/ vorliegenden Publikationen zusammengestellt und dies für eine Textanalyse vorbereitet haben. Exemplarisch wird die Häufung von medienwissenschaftlichen Fachbegriffen betrachtet und diese mithilfe einer Datenvisualisierung und Wortwolken präsentiert.\nUm unsere Analysen allgemein nachvollziehbar zu machen, haben wir zudem die von uns erarbeiteten Python-Skripte geteilt:\nhttps://mediarep.org/entities/dataset/5c425f93-ff08-4844-a36f-fdc912f143f2\nEin Skript ermöglicht den Download von Publikationen aus media/rep/ im txt-Format sowie der zugehörigen Metadaten als csv-Datei. Zudem wird ein Jupyter Notebook für die Analyse der Texte bereitgestellt."
  },
  {
    "objectID": "mediarep.html#die-vermessung-der-medienwissenschaftlichen-welt-datengestützte-analysen-mit-mediarep",
    "href": "mediarep.html#die-vermessung-der-medienwissenschaftlichen-welt-datengestützte-analysen-mit-mediarep",
    "title": "Datengestützte Analysen mit media/rep/",
    "section": "",
    "text": "Das DiCi-Hub-Projekt hat sich für eine Analyse von medienwissenschaftlichen Daten mit dem Open Access-Repositorium für medienwissenschaftliche Publikationen media/rep/ zusammengetan. Wir haben uns der Frage gewidmet, wie sich bestehende Forschungsinfrastrukturen für datengestützte Analysen nutzen lassen. Konkret gesagt war unser Ziel, die in media/rep/ vorliegenden Publikationen mit ihren zugehörigen Metadaten mithilfe von digitalen Methoden auszuwerten und dadurch fachhistorische Perspektiven der deutschen Medienwissenschaft zu erkunden.\nDie ersten Ergebnisse der Analyse sind nun online in der Zeitschrift für Medienwissenschaft erschienen:\nhttps://zfmedienwissenschaft.de/online/die-vermessung-der-medienwissenschaftlichen-welt\nWir beschreiben darin, wie wir uns ein Textkorpus aus den in media/rep/ vorliegenden Publikationen zusammengestellt und dies für eine Textanalyse vorbereitet haben. Exemplarisch wird die Häufung von medienwissenschaftlichen Fachbegriffen betrachtet und diese mithilfe einer Datenvisualisierung und Wortwolken präsentiert.\nUm unsere Analysen allgemein nachvollziehbar zu machen, haben wir zudem die von uns erarbeiteten Python-Skripte geteilt:\nhttps://mediarep.org/entities/dataset/5c425f93-ff08-4844-a36f-fdc912f143f2\nEin Skript ermöglicht den Download von Publikationen aus media/rep/ im txt-Format sowie der zugehörigen Metadaten als csv-Datei. Zudem wird ein Jupyter Notebook für die Analyse der Texte bereitgestellt."
  },
  {
    "objectID": "dicihub_mediarep/Textanalyse.html",
    "href": "dicihub_mediarep/Textanalyse.html",
    "title": "Die Vermessung der medienwissenschaftlichen Welt?",
    "section": "",
    "text": "Dieses Jupyter Notebook soll eine Grundlage bieten, die im Fachrepositorium media/rep/ vorhandenen Texte und die dazugehörigen Metadaten mithilfe eines Python-Skriptes zu analysieren. Hierzu werden Abschnitte für die Vorbereitung von Texten zur Analyse (Entfernung von Stoppwörtern, Neuzusammenstellung des Textkorpus, Gruppierung von Texten nach Jahreszahlen) sowie ein Durchsuchen der Texte nach konkreten Begriffen (als vollständige Wörter oder in Form einer Wildcard-Suche, Identifizierung von einzelnen Wortformen und -kombinationen bei einer Wildcard-Suche, Identifizierung von Einzeltexten, die einen Suchbegriff vermehrt enthalten) bereitgestellt. Funktional orientiert sich dieses Jupyter Notebook damit an Textanalysetools wie Voyant.\nGenerell eignet sich der bereit gestellte Code auch für die Analyse anderer Texte, die in demselben Format wie das media/rep/-Korpus vorliegen, wobei jedoch an einigen Stellen Anpassungen notwendig sein dürften.\nUm das Notebook nutzen zu können, sind Grundkenntnisse in Python und im Umgang mit Jupyter Notebooks notwendig. Als ein Ergebnis aus der Zusammenarbeit von Medienwissenschaft und Digital Humanities ist das Notebook nicht daraufhin überarbeitet worden, eine möglichst hohe Performanz in der Umsetzung der Analyseschritte zu erreichen. Die Kommentierung der einzelnen Code-Abschnitte dient vor allem dazu, transparent zu machen, welche Schritte durchgeführt wurden, um die Analyseergebnisse zu erzielen.\n\n\n\nVorbedingungen\nTextpreprocessing\n\nEingrenzung des Korpus\n\nGruppierung von Texten nach Publikationsjahr\n\nEntfernen von Stoppwörtern\n\n\nTextanalyse\n\nSuche nach vollständigen Wörtern oder Wildcard-Suche\n\nIdentifizierung von verschiedenen Wortformen und -kombinationen einzelner Suchbegriffe bei einer Wildcard-Suche\n\nIdentifizierung von Einzeltexten, die einen Suchbegriff enthalten"
  },
  {
    "objectID": "dicihub_mediarep/Textanalyse.html#datengestützte-analysen-mit-mediarep",
    "href": "dicihub_mediarep/Textanalyse.html#datengestützte-analysen-mit-mediarep",
    "title": "Die Vermessung der medienwissenschaftlichen Welt?",
    "section": "",
    "text": "Dieses Jupyter Notebook soll eine Grundlage bieten, die im Fachrepositorium media/rep/ vorhandenen Texte und die dazugehörigen Metadaten mithilfe eines Python-Skriptes zu analysieren. Hierzu werden Abschnitte für die Vorbereitung von Texten zur Analyse (Entfernung von Stoppwörtern, Neuzusammenstellung des Textkorpus, Gruppierung von Texten nach Jahreszahlen) sowie ein Durchsuchen der Texte nach konkreten Begriffen (als vollständige Wörter oder in Form einer Wildcard-Suche, Identifizierung von einzelnen Wortformen und -kombinationen bei einer Wildcard-Suche, Identifizierung von Einzeltexten, die einen Suchbegriff vermehrt enthalten) bereitgestellt. Funktional orientiert sich dieses Jupyter Notebook damit an Textanalysetools wie Voyant.\nGenerell eignet sich der bereit gestellte Code auch für die Analyse anderer Texte, die in demselben Format wie das media/rep/-Korpus vorliegen, wobei jedoch an einigen Stellen Anpassungen notwendig sein dürften.\nUm das Notebook nutzen zu können, sind Grundkenntnisse in Python und im Umgang mit Jupyter Notebooks notwendig. Als ein Ergebnis aus der Zusammenarbeit von Medienwissenschaft und Digital Humanities ist das Notebook nicht daraufhin überarbeitet worden, eine möglichst hohe Performanz in der Umsetzung der Analyseschritte zu erreichen. Die Kommentierung der einzelnen Code-Abschnitte dient vor allem dazu, transparent zu machen, welche Schritte durchgeführt wurden, um die Analyseergebnisse zu erzielen.\n\n\n\nVorbedingungen\nTextpreprocessing\n\nEingrenzung des Korpus\n\nGruppierung von Texten nach Publikationsjahr\n\nEntfernen von Stoppwörtern\n\n\nTextanalyse\n\nSuche nach vollständigen Wörtern oder Wildcard-Suche\n\nIdentifizierung von verschiedenen Wortformen und -kombinationen einzelner Suchbegriffe bei einer Wildcard-Suche\n\nIdentifizierung von Einzeltexten, die einen Suchbegriff enthalten"
  },
  {
    "objectID": "dicihub_mediarep/Textanalyse.html#vorbedingungen",
    "href": "dicihub_mediarep/Textanalyse.html#vorbedingungen",
    "title": "Die Vermessung der medienwissenschaftlichen Welt?",
    "section": "Vorbedingungen ",
    "text": "Vorbedingungen \nDie Analysegrundlage für dieses Jupyter Notebook stellen die im Fachrepositorium media/rep/ vorliegenden Publikationen dar. Diese können mithilfe eines Python-Skriptes im txt-Format heruntergeladen werden, wobei gleichzeitig eine Metadatentabelle generiert wird. Dieses Skript wird separat von diesem Jupyter Notebook zur Verfügung gestellt.\nFür die Nutzung der in diesem Jupyter Notebook zur Verfügung gestellten Funktionalitäten ist es notwendig, die mittels des Skripts extrahierten txt-Dateien in einem Dateiordner zu speichern, der wiederum in einem übergeordneten Verzeichnis liegt, in der auch die bei Abruf der txt-Dateien automatisch gespeicherte Metadatentabelle sowie dieses Jupyter Notebook gespeichert werden. Hinzu kommt noch eine Stoppwortliste, die im Rahmen des Textpreprocessing verwendet wird und hier ebenfalls separat zur Verfügung gestellt wird. Diese vorgeschlagene Struktur gilt sowohl für die Nutzung des Jupyter Notebooks in einer IDE als auch einer Jupyter Umgebung. Die Ordnerstruktur sollte dementsprechend wie folgt aussehen:\nHauptverzeichnis\n– &gt; Dateiordner mit txt-Dateien\n——- &gt; 1988_….txt\n——- &gt; 2013_….txt\n——- &gt; …\n——- &gt; 2020_….txt\n– &gt; Metadatentabelle.csv\n– &gt; Jupyter Notebook.ipynb\n– &gt; Stoppwortliste.txt\nDie Benennung der aus media/rep/ extrahierten txt-Dateien sollte grundsätzlich beibehalten werden, da einige Schritte des Textpreprocessings an die automatisch generierten Dateinamen angepasst sind. Die Benennung des Dateiordners mit den txt-Dateien sowie die Benennung der Metadatentabelle sind frei wählbar und werden an gekennzeichneten Stellen in diesem Jupyter Notebook abgefragt, um die Analyseschritte darauf durchführen zu können.\nGenerell empfiehlt es sich, eine Kopie der aus media/rep/ extrahierten Texte zu behalten, da durch das Textpreprocessing Inhalte verändert werden können. Um den Zustand der einzelnen Zwischenschritte des Preprocessing zu speichern, werden in den nachfolgenden Skripten automatisch neue Dateiordner generiert, in dem die bearbeiteten Dateien gespeichert werden.\nDer in diesem Jupyter Notebook zur Verfügung gestellte Code wurde mit den Python-Versionen 3.8 - 3.11 getestet. Zur Nutzung aller Funktionalitäten des Notebooks ist die Installation und der Import folgender Libraries notwendig:\n\n#Textbereinigung\nimport re\n#Einlesen der txt-Dateien\nimport os\nimport glob\nfrom pathlib import Path\nimport shutil\n#Erstellung von Dataframes und Berechnungen auf diesen\nimport pandas as pd\n#Visualisierungen (Styling und Darstellung)\nimport pygal \nfrom pygal.style import Style\nimport cairosvg\nimport lxml\nimport tinycss2\nimport cssselect2\n#Wortwolken\nimport matplotlib.pyplot as plt\nfrom wordcloud import WordCloud\n\nDas Jupyter Notebook ist vom Prinzip her so aufgebaut, dass dem eigentlichen Skript jeweils eine Code-Zelle vorgelagert ist, in der beispielsweise Angaben zu dem Ordnernamen, der die zu analysierenden Dateien enthält, zu Suchbegriffen oder der Jahresrange der zu analysierenden Texte gemacht werden müssen.\nAufgrund der Größe des media/rep/-Textkorpus kann das Durchlaufen einer Code-Zelle je nach Bearbeitungsschritt bis zu 4 Minuten betragen."
  },
  {
    "objectID": "dicihub_mediarep/Textanalyse.html#textpreprocessing",
    "href": "dicihub_mediarep/Textanalyse.html#textpreprocessing",
    "title": "Die Vermessung der medienwissenschaftlichen Welt?",
    "section": "Textpreprocessing ",
    "text": "Textpreprocessing \n\nEingrenzung des Korpus \nDas Herunterladen von txt-Dateien aus media/rep/ lässt sich bereits über das oben erwähnte Skript den Analysebedürfnissen entsprechend anpassen, indem nur bestimmte Teile des Korpus extrahiert bzw. nicht extrahiert werden. Aber auch nach Herunterladen des Gesamtkorpus besteht die Möglichkeit, dieses in kleinere Teil-Korpora zu zerlegen, um gezielt Analysen auf beispielsweise allen publizierten Rezensionen oder auf allen Ausgaben einer spezifischen Zeitschrift eines bestimmten Zeitraums durchzuführen. Dies kann durch Auswählen oder Ausschließen eines bestimmten Teils des Korpus geschehen. In dem eingangs erwähnten Artikel wurde für die Analyse beispielsweise die Publikationsform PeriodicalPart nicht mitberücksichtigt, da darin einige Publikations-Items vorliegen, die gleichzeitig als review oder article geführt werden und somit doppelt in die Analyse eingeflossen wären. Dies gilt vereinzelt auch für book und bookPart.\nmedia/rep/ bietet unter anderem folgende Publikationsformen: review, article, PeriodicalPart, book, bookPart, workingPaper, doctoralThesis, report\nDes Weiteren sind verschiedene Publikationsreihen - sowohl Buch als auch Zeitschrift - vorhanden, die über eine ISSN-Nummer identifiziert werden können. Beispielsweise ist die Zeitschrift ‘MEDIENwissenschaft: Rezensionen | Reviews’ mit der ‘issn:2196-4270’ verknüpft. Einen Überblick über die Publikationsreihen und ihre jeweiligen ISSN-Nummern bietet die beim Herunterladen der txt-Dateien automatisch generierte Metadatentabelle.\nAls weitere Filtermöglichkeiten bietet sich zudem die Auswahl bestimmter Publikationsjahre oder Autor*innen an. Auch hierfür bietet die Metadatentabelle einen guten Überblick.\nUm die nachfolgenden Schritte durchführen zu können, dürfen die Dateinamen der aus media/rep/ extrahierten Dateien nicht nachträglich verändert worden sein, sondern müssen in ihrem Originalzustand belassen werden. Dies gilt auch für die in der Metadatentabelle aufgeführten Dateinamen.\n\n'''\nEinzufügen ist der Name der aus media/rep/ gewonnenen Metadaten-Datei, \ndie dann in einen Dataframe eingelesen wird.\n'''\nmetadata = \"\" #z.B. \"metadata.csv\"\n\ndf_metadata = pd.read_csv(metadata, low_memory=False)\n\n'''\nNachfolgend sind die verschiedenen Filteroptionen gelistet, \ndie durch Entkommentieren ausgewählt werden können. \nEs besteht die Möglichkeit, Parameter auszuschließen (excluded) \noder gezielt auszuwählen (included).\nDie ausgewählten Parameter können in die jeweils leere Liste, \ndie .isin([ ]) folgt, eingetragen werden.\nFür jede Filteroption wird ein Beispiel gezeigt.\n'''\n\n'''\nOption 1: Filtern nach Erscheinungsjahr\nWählt oder schließt die Publikationen aus, \ndie in den in der Liste eingetragenen Erscheinungsjahren publiziert wurden.\nBeispiel: \nyears_excluded = df_metadata['dc.date.issued'].isin([\"2012\", \"2013\", \"2014\"]) == False \nschließt alle Publikationen aus, die in den genannten Jahren publiziert wurden.\nDas Erscheinungsjahr bezieht sich nicht auf die Publikation in media/rep/, \nsondern auf die Erstpublikation.\nDie ersten drei Code-Zeilen müssen unverändert übernommen werden. \nDa die in media/rep/ enthaltenen Jahresangaben \nunterschiedlichen Formaten folgen, müssen diese angeglichen werden.\n'''\n#years = df_metadata[\"dc.date.issued\"].to_list()\n#years = [i[:4] for i in years]\n#df_metadata[\"dc.date.issued\"] = years\n#years_excluded = df_metadata['dc.date.issued'].isin([]) == False\n#years_included = df_metadata['dc.date.issued'].isin([]) \n\n'''\nOption 2: Filtern nach Publikationsformat\nWählt oder schließt die Publikationen aus, \ndie in den in der Liste eingetragenen Publikationsformaten publiziert wurden.\nBeispiel: \ntypes_included = df_metadata['dc.type'].isin([\"article\", \"PeriodicalPart\"]) \nwählt alle Publikationen aus, \ndie als article und PeriodicalPart publiziert wurden.\n'''\n#types_excluded = df_metadata['dc.type'].isin([]) == False\n#types_included = df_metadata['dc.type'].isin([])\n\n'''\nOption 3:\nWählt oder schließt die Publikationen aus, \ndie in den in der Liste eingetragenen Publikationsreihen publiziert wurden.\nBeispiel: \nisPartof_excluded = df_metadata['dc.relation.isPartOf'].isin([\"issn:2196-4270\"]) == False \nschließt alle Publikationen der Zeitschrift \"MEDIENwissenschaft: Rezensionen | Reviews\" aus.\n'''\n#isPartof_excluded = df_metadata['dc.relation.isPartOf'].isin([]) == False\n#isPartof_included = df_metadata['dc.relation.isPartOf'].isin([])\n\n'''\nOption 4:\nWählt oder schließt die Publikationen aus, \ndie von bestimmten Autor*innen verfasst wurden.\nBeispiel: \ncreator_included = df_metadata['dc.creator'].isin([\"Kessler, Frank\"])\nwählt nur Publikationen aus, \ndie von genanntem Autor verfasst wurden.\n'''\n#creator_excluded = df_metadata['dc.creator'].isin([]) == False\n#creator_included = df_metadata['dc.creator'].isin([])\n\n'''\nUm mehrere Filteroptionen gemeinsam nutzen zu können, \nmüssen diese mit ihren oben genannten Variablennamen in der gewünschten \nReihenfolge des Filterns in die nachstehende Liste eingetragen werden.\nBeispielsweise ließen sich somit zuerst alle article auswählen \nund in einem zweiten Schritt die Auswahl auf bestimmte Jahre eingrenzen.\nDie einzelnen Variablen müssen dabei mit dem & Zeichen verbunden werden.\n'''\nfilter = #z.B. types_excluded & years_excluded\n\n'''\nEinzufügen ist der Name des Ordners, \nin dem sich alle aus media/rep/ extrahierten Texte befinden.\n'''\nfolder = \"\" #z.B. \"fulltext\"\n\n'''\nEinzufügen ist der Name des Ordners, \nin dem die ausgewählten Dateien gespeichert werden sollen \n(dieser wird automatisch in diesem Verzeichnis generiert).\n'''\nfiltered_folder = \"\" #z.B. \"filtered_corpus\"\n\nos.mkdir(filtered_folder)\n\n\n'''\nDer Dataframe wird nach den ausgewählten Optionen gefiltert.\n'''\ndf_metadata_filtered = df_metadata.loc[filter]\n\n'''\nDie Dateinamen aller übrig gebliebenen Einträge im Dataframe \nwerden in eine Liste überführt.\n'''\nfilenames_list = df_metadata_filtered[\"fulltext_file\"].to_list()\n\n'''\nDie Dateinamen in der Liste werden mit den Dateinamen \nder im Ordner vorhandenen txt-Dateien abgeglichen.\nWenn ein Dateiname im Ordner auf der Liste zu finden ist, \nwird diese Datei in den neu erstellten Ordner kopiert, \nder abschließend das neu erstellte Textkorpus enthält.\n'''\nfor filename in os.listdir(folder):\n    if filename in filenames_list:\n        full_file_path = os.path.join(folder, filename)\n        shutil.copy((os.path.join(folder, filename)), filtered_folder)\n\n\nGruppierung von Texten nach Publikationsjahr \nEin Gesamtabzug des media/rep/-Korpus besteht aus einer Menge von über 18.000 Texten (Stand Januar 2023). Abhängig von den jeweiligen Analysefragen können diese Texte separat betrachtet werden. Insbesondere für eine Visualisierung von Ergebnissen ist es jedoch notwendig, diese Dateien zu gruppieren. Hierzu bietet sich eine Gruppierung nach Publikationsjahr an. Hierbei ist nicht das Jahr der Publikation in media/rep/, sondern das Jahr der Erstpublikation relevant.\n\n'''\nEinzufügen ist der Name des Ordners, \nin dem sich alle aus media/rep/ extrahierten Texte befinden.\n'''\nfolder = \"\" #z.B. \"fulltext\"\n\n'''\nEinzufügen ist der Name des Ordners, \nin dem die neu zusammengeführten Dateien gespeichert werden sollen \n(dieser wird automatisch in diesem Verzeichnis generiert).\nEs ist sinnvoll, diese nach Jahreszahlen gruppierten txt-Dateien \nin einem separaten Ordner zu speichern, \nda diese ansonsten inmitten der zehntausenden Dateien \ndes bereits vorhandenen Ordners gespeichert würden \nund manuell herausgesucht werden müssten.\n'''\nyear_folder = \"\" #z.B. \"fulltext_by_year\"\n\nos.mkdir(year_folder)\n\n\n'''\nDie vorhandenen Jahreszahlen werden \naus den Dateinamen im gewählten Ordner extrahiert \nund in eine Liste überführt, \nwobei Duplikate entfernt \nund die Liste aufsteigend sortiert wird.\n'''\nyears = [year for file in os.listdir(folder) for year in re.findall(\"(\\d{4})_\", file)]\nyears = list(dict.fromkeys(years))\nyears.sort()\n\n'''\nDie txt-Dateien, die zusammengeführt werden sollen, \nwerden zusammen gemäß ihrem Publikationsjahr \naus dem enstprechenden Ordner eingelesen.\n'''\nfor year in years:\n    files = glob.glob(os.path.join(f\"{folder}\", f\"{year}_*.txt\"))                   \n    '''\n    Die nach Jahren eingelesenen Texte werden in dem neu erstellten Ordner\n    als eine gemeinsame txt-Datei pro Jahr erstellt.\n    '''\n    with open(os.path.join(f\"{year_folder}\", f\"{year}_fulltext.txt\"), \"wb\") as outfile:\n        for f in files:\n            with open(f, \"rb\") as infile:\n                outfile.write(infile.read())\n\n\n\n\nEntfernen von Stoppwörtern \nUm eine Textanalyse durchzuführen, bietet es sich an, vorab Stoppwörter zu entfernen, die für die Analyse nicht relevant sind (z.B. Präpositionen, Artikel, Füllwörter). Aufgrund der Größe des media/rep/-Korpus wird die inhaltliche Analyse der Texte durch das Entfernen von Stoppwörtern beschleunigt und erlaubt eine Fokussierung auf für das Textverständnis bedeutende Wörter. Dies ist insbesondere dann notwendig, wenn die inhaltliche Analyse das Ermitteln der häufigsten (semantisch bedeutsamen) Wörter beinhaltet. Im Rahmen der hier vorgestellten Analyse ist die Entfernung von Stoppwörtern zwar zu empfehlen, aber nicht zwingend erforderlich, da einer deduktiven Logik gefolgt und eine gezielte Suche nach Begriffen ermöglicht wird. Dies steht einem induktiven Ansatz gegenüber, bei dem durch Ermittlung von Worthäufigkeiten aller Wörter der Texte nach den häufigsten Begriffen gesucht wird. Letzteres stellt aufgrund der Größe des media/rep/-Korpus eine Herausforderung dar und erfordert eine zusätzliche Strategie, was den Umgang mit Stoppwörtern und der gemeinsamen Analyse verschiedener Wortformen angeht, und bietet sich somit für eine eigene Untersuchung an.\nZur Entfernung von Stoppwörtern kann auf eine im Kontext dieses Projektes erstellte Stoppwortliste zugegriffen werden, die auf der deutschen und englischen Stoppwortliste des Textanalysetools Voyant basiert und zusätzlich spezifisch dem media/rep/-Korpus angepasste Begriffe enthält.\nDiese txt-Datei und somit die Auswahl und Anzahl der Stoppwörter kann je nach Bedarf angepasst werden. Vorraussetzung für die nachfolgenden Schritte ist, dass die Stoppwortliste in demselben Verzeichnis gespeichert ist wie dieses Jupyter Notebook.\n\n'''\nEinzufügen ist der Name der Stoppwortliste.\n'''\nstopword_list = \"\" #z.B. \"stopwords.txt\"\n\n'''\nEinzufügen ist der Name des Ordners, \nin dem sich alle aus media/rep/ extrahierten Texte befinden.\n'''\nfolder = \"\" #z.B. \"fulltext_by_year\"\n\n'''\nEinzufügen ist der Name des Ordners, \nin dem die nach Stoppwörtern gefilterten Dateien gespeichert werden sollen \n(dieser wird automatisch in diesem Verzeichnis generiert).\n'''\nstopword_folder = \"\" #z.B. \"stopwordfiltered_by_year\"\n\nos.mkdir(stopword_folder)\n\n\n'''\nEinlesen der txt-Datei mit der Stoppworliste\nund Überführen der Stoppwörter in eine Liste.\n'''\nwith open(stopword_list, \"r\", encoding=\"utf-8\") as infile1:\n    stopwords = [word.rstrip() for word in infile1]\n\n'''\nJede im Dateiordner vorliegende txt-Datei \nwird nacheinander eingelesen \nund verschiedene Textbereinigungsschritte durchgeführt.\n'''\nfor file in glob.glob(os.path.join(f\"{folder}\", \"*.txt\")):\n    with open(file, \"r\", encoding=\"utf-8\") as infile2:\n        text_stop = infile2.read()\n        '''\n        Am Ende einer Zeile durch Worttrennung \n        voneinander getrennte Wörter \n        werden zusammengeführt. \n        Zahlen, Zeilenumbrüche und Nicht-Wortzeichen \n        werden entfernt \n        und durch ein Leerzeichen ersetzt.\n        '''\n        text_stop = re.sub(\"-\\n+|\\d\", \"\", text_stop)\n        text_stop = re.sub(\"\\n|\\W+\", \" \", text_stop)\n        \n        '''\n        Die Stoppwörter werden aus den Texten entfernt, \n        indem die Wörter eines Textes \n        jeweils von einem String in eine Liste überführt \n        und die Stoppwörter aus dieser Liste herausgefiltert werden. \n        Anschließend wird die übriggebliebene Wortliste \n        eines jeden Textes wieder in einen String überführt. \n        ''' \n        text_stop = ' '.join([word for word in text_stop.split() if word.lower() not in stopwords])\n\n        '''\n        Die Dateinamen der eingelesenen Texte \n        werden auf ihren Kernnamen reduziert \n        (Dateierweiterung, Dateipfad wird entfernt).\n        '''\n        filename = Path(file).stem\n\n        '''\n        Die nach Stoppwörtern gefilterten Texte \n        werden in dem neu erstellten Ordner gespeichert.\n        '''\n        with open(os.path.join(f\"{stopword_folder}\", f\"{filename}.txt\"), \"w\", encoding=\"utf-8\") as outfile:\n            output_text = outfile.write(text_stop)"
  },
  {
    "objectID": "dicihub_mediarep/Textanalyse.html#textanalyse",
    "href": "dicihub_mediarep/Textanalyse.html#textanalyse",
    "title": "Die Vermessung der medienwissenschaftlichen Welt?",
    "section": "Textanalyse ",
    "text": "Textanalyse \nDer folgende Abschnitt bezieht sich auf die Suche nach Wörtern in dem vorab erstellten Textkorpus und einer Visualisierung von Ergebnissen. Zum einen wird eine Suche nach vollständigen Wörtern bereitgestellt, zum anderen eine Wildcard-Suche, bei der lediglich der Anfang eines Wortes eingegeben werden muss und alle verschiedenen Endungsmöglichkeiten des Wortes in der Suche mitberücksichtigt werden. Die Ergebnisse werden in einen Dataframe überführt und können als csv-Datei gespeichert werden oder in Form eines Liniendiagramms betrachtet werden.\nUm bei der Häufigkeitsanalyse die unterschiedliche Länge von Publikationen mitberücksichtigen zu können, werden relative statt absolute Zahlen in den Ergebnissen präsentiert. Dies bedeutet, dass die Häufigkeit des Vorkommens eines Suchbegriffes in einem Text in Relation zu der Gesamtzahl der Wörter eines Textes gesetzt wird. Abhängig davon, ob während des Textpreprocessing Stoppwörter aus den Texten entfernt wurden oder nicht, steht die ermittelte Anzahl der Wörter eines vorbearbeiteten Textes nicht in jedem Fall für die eigentliche Gesamtlänge eines Textes. Wurden die Stoppwörter vorab entfernt, sind die relativen Werte höher, als wenn sie in Bezug auf die Gesamtlänge eines unbereinigten Textes berechnet würden. Ein isoliert betrachteter Wert ist daher nicht aussagekräftig. Erst die Kontextualisierung und der Vergleich mit weiteren Werten lässt Schlussfolgerungen über die Häufigkeit der Suchbegriffe zu.\nUm eine übersichtliche Ergebnismenge zu generieren, bedarf es insbesondere hier einer Gruppierung der ursprünglich mehr als 18.000 Texte aus media/rep/. Hierzu bietet sich die Gruppierung nach Jahren an, wobei insbesondere der Zeitraum zwischen 1980 und 2020 eine repräsentative Textbasis für die Analyse bietet.\n\nSuche nach vollständigen Wörtern oder Wildcard-Suche \n\n'''\nIn die Liste keywords können die Suchbegriffe eingefügt werden. \nDiese müssen kleingeschrieben werden.\nEs besteht die Möglichkeit einen vollständigen Begriff einzugeben, \nder in exakt dieser Form gesucht wird. \nBeispiel: \nDer Suchbegriff \"digital\" würde nicht die Vorkommen von \n\"digitale\", \"digitales\" etc. berücksichtigen, \nsondern nur den Begriff exakt wie er geschrieben wird.\nEs besteht aber auch die Möglichkeit \nnur die Anfangsbuchstaben eines Begriffes einzugeben, \num verschiedene Wortformen und -kombinationen mitzuberücksichtigen \nBeispiel: \nDer Suchbegriff \"digital\" würde alle Wörter berücksichtigen, \nbei denen \"digital\" den Beginn des Wortes darstellt: \n\"digitales\", \"digitalität\", \"digitalpakt\" etc.\nOb eine Suche nach vollständigen Wörtern \noder eine Wildcard-Suche gewünscht ist, \nmuss in der nachfolgenden Code-Zelle \nan der gekennzeichneten Stelle gewählt werden.\nPrinzipiell können so viele Suchbegriffe eingegeben werden, \nwie gewünscht ist. \nZu viele Begriffe bedeuten jedoch auch eine größere Anzahl von Linien\nim erstellten Diagramm, was zu Unübersichtlichkeit führen kann. \nEs ist daher empfehlenswert, maximal 6 Suchbegriffe zu wählen.\n'''\nkeywords = [] # z.B. [\"virtuell\", \"internet\", \"netz\", \"online\", \"interaktiv\", \"digital\"]\n\n'''\nEinzufügen ist der Name des Dateiordners, \nder die zu analysierenden txt-Dateien enthält.\n'''\nfolder = \"\" #z.B. stopwordfiltered_by_year\n\n'''\nEinzufügen ist die Range der untersuchten Texte als Index \nfür den zu erstellenden Dataframe mit den Analyseergebnissen \nsowie für die Beschriftung der Visualisierung.\nDies ist abhängig von der untersuchten Textgrundlage. \nSind die Texte beispielsweise nach Jahren gruppiert \nund stammen aus den Jahren 1980-2020 \nist die range(1980, 2021, 1) zu wählen \n(zur Erklärung der range-Funktion siehe\nhttps://docs.python.org/3/library/functions.html#func-range).\n'''\nrange_texts = range(1980, 2021, 1)\n\n'''\nEinzufügen ist der Dateiname für die Speicherung der Ergebnisse als csv-Datei\n'''\nname_csv = \"\" #z.B. \"suche_digit_virtu\"\n\n'''\nEinzufügen ist der Dateiname für die Speicherung der Ergebnisdiagramme (png, svg)\n'''\nname_chart = \"\" #z.B. \"suche_digit_virtu\"\n\nBITTE BEACHTEN: Für die Auswahl zwischen einer Suche nach vollständigen Wörtern und einer Wildcard-Suche müssen im folgenden Abschnitt an gekennzeichneter Stelle Code-Zeilen auskommentiert bzw. entkommentiert werden.\n\n'''\nAnlegen eines leeren Dataframe, \num die Ergebnisse der Häufigkeitsermittlung darin festzuhalten.\n'''\ndf_results = pd.DataFrame()\n\n'''\nAnlegen einer leeren Liste, \nin der die Gesamtzahl der Wörter der einzelnen Texte gespeichert wird \n(relevant für die Berechnung von relativen Häufigkeiten).\n'''\nnumber_words = []\n\n'''\nAnlegen eines Dictionary, \nin dem die Suchbegriffe jeweils als key gespeichert werden \nund als value eine leere Liste angelegt wird, \nin der im Folgenden die Häufigkeit des Suchbegriffs \nin den einzelnen Texten eingefügt wird.\n'''\nfrequency_keywords = {key:[] for key in keywords}\n\n'''\nJede im Dateiordner vorliegende Textdatei \nwird nacheinander eingelesen \nund die Texte zur besseren Vergleichbarkeit \nvollständig in Kleinbuchstaben umgewandelt.\n'''\nfor file in glob.glob(os.path.join(f\"{folder}\", \"*.txt\")):\n    with open(file, \"r\", encoding=\"utf-8\") as infile:\n        fulltext = infile.read().lower()\n\n        '''\n        Jeder Text wird von einem String in eine Wortliste umgewandelt, \n        wobei die Wörter an den Nicht-Wortzeichen gesplittet werden.\n        '''\n        fulltext_list = re.split(\"\\W+\", fulltext)\n\n        '''\n        Die Länge der jeweils erstellten Wortlisten gibt Auskunft über die Länge des Textes \n        und wird für jeden Text einer Liste hinzugefügt.\n        '''\n        number_words.append(len(fulltext_list))\n\n        '''\n        Erstellen eines Dictionary für jeden Text.\n        Hierzu wird über die Wortliste eines jeden Textes iteriert \n        und die gefundenen Suchbegriffe als keys dem Dictionary hinzugefügt. \n        Bei erstmaligem Vorkommen erhält der Suchbegriff 1 als value.\n        Taucht der Suchbegriff mehrfach im Text auf, \n        wird der value für jedes Vorkommen hochgezählt.\n        '''\n        fulltext_dict = {}\n        for i in fulltext_list:\n                if i in fulltext_dict:\n                    fulltext_dict[i] +=1\n                else:\n                    fulltext_dict[i] = 1\n        \n        '''\n        Aus den für die einzelnen Texte erstellen Dictionaries \n        werden nur die gesuchten Begriffe ausgewählt.\n        Die Anzahl des Vorkommens der einzelnen Suchbegriffe wird pro Text summiert. \n        Die summierten Ergebnisse werden in Form einer Liste \n        als value dem eingangs erstellten Dictionary hinzugefügt.\n        '''\n        \n        '''\n        EINE DER BEIDEN FOLGENDEN OPTIONEN WÄHLEN UND DIE ANDERE AUSKOMMENTIEREN:\n        OPTION 1: SUCHE NACH VOLLSTÄNDIGEN WÖRTERN\n        '''\n        # for i in keywords:\n        #     keywords_dict = {k: v for k, v in fulltext_dict.items() if k == i}\n        #     frequency_keywords[i].append(sum(keywords_dict.values()))\n\n        '''\n        OPTION 2: WILDCARD_SUCHE\n        '''\n        # for i in keywords:\n        #    keywords_dict = {k: v for k, v in fulltext_dict.items() if k.startswith(i)}\n        #    frequency_keywords[i].append(sum(keywords_dict.values()))\n\n'''\nDie Ergebnisse aus dem Dictionary \nsowie die Anzahl der Wörter pro Text \nwerden in den Dataframe eingefügt. \nDie eingangs definierte Text-Range \ndient als Index des Dataframe.\n'''\ndf_results.index = range_texts\nfor k,v in frequency_keywords.items():\n   df_results[k] = v\ndf_results[\"words\"] = number_words\n\n'''\nUm relative Werte zu erhalten, \nwird die Anzahl des Vorkommens der keywords \ndurch die Gesamtzahl der Wörter eines Textes dividiert.\nFür eine intiuitivere Erfassung der entstandenen Werte \nwird das Ergebnis mit 1000 multipliziert, \nso dass damit die Häufigkeit des Vorkommens eines Suchbegriffs \npro 1000 Wörter Text dargestellt werden kann.\nDie Kolumne mit der Gesamtzahl der Wörter eines Textes \nwird anschließend gelöscht, \nda sie für die Erstellung der Visualisierung irrelevant ist.\n'''\nfor column in df_results:\n    df_results[column] = df_results.loc[:,column].div(df_results.loc[:,\"words\"], axis = 0) * 1000\ndf_results = df_results.drop(['words'], axis = 1)\n\n'''\nSpeichern der Ergebnisse in einer csv-Datei\n'''\ndf_results.to_csv(f\"{name_csv}.csv\")\n\nZusätzlich zur vorangehenden Code-Zelle kann die nachfolgende Code-Zelle ausgeführt werden, um die Ergebnisse in Form eines Liniendiagramms darzustellen oder zu speichern.\n\n'''\nFestlegen der Parameter für die Visualisierung \n(Farbe der Kurven, Schriftart und -größe für die Beschriftung des Diagramms, \nStrichstärke für Diagrammlinien)\n'''\ndiagram_style = Style(\n    colors=('#FF0000', '#00FF00', '#0000FF', '#8A2BE2', '#000000', '#FFCC33'),\n    font_family='googlefont:Anuphan',\n    title_font_size=24,\n    label_font_size=13,\n    major_label_font_size=13,\n    guide_stroke_dasharray=0,\n    major_guide_stroke_dasharray=0)\n\n'''\nErstellen eines Liniendiagramms aus den im Dataframe ermittelten Werten \n(für den Hintergrund der kubischen Interpolation \nsiehe https://de.wikipedia.org/wiki/Spline-Interpolation)\n'''\nlinechart_results = pygal.Line(style = diagram_style, x_label_rotation = 60, interpolate = \"cubic\")\nlinechart_results.title = \"Häufigkeit des Vorkommens der analysierten Begriffe pro 1000 Wörter des Gesamttexts\"\nlinechart_results.x_labels = range_texts\nfor column in df_results:\n    linechart_results.add(f'{column}', df_results.loc[:,column])\n\n'''\nDarstellen des Liniendiagramms\n'''\nlinechart_results\n\n\n#Zum Speichern des erstellten Diagramms als svg oder png \n#können die nachfolgenden Code-Zeilen entkommentiert werden.\n\n#linechart_results.render_to_file(f\"{name_chart}.svg\")\n#linechart_results.render_to_png(f\"{name_chart}.png\")\n\n\n\nIdentifizierung von verschiedenen Wortformen und -kombinationen einzelner Suchbegriffe bei einer Wildcard-Suche \nDurch die oben beschriebene Wildcard-Suche wird nicht ersichtlich, welche Wortformen und -kombinationen für die einzelnen Suchbegriffe berücksichtigt werden. Das nachfolgende Skript soll die Möglichkeit bieten, diese einzelnen Formen zu identifizieren, um eine stärkere Transparenz über die Ergebnisse der Wortzählung zu erzielen. Hierzu ist immer nur ein Suchbegriff auf einmal einzugeben (keine Liste von Suchbegriffen).\n\n'''\nEinzufügen ist das Suchwort, \nfür das die ermittelten Einzelformen ausgegeben werden sollen. \nBeispiel:\nDie Suche nach \"postkol\" würde die Anzahl an Einzelformen \nwie Postkolonialismus, postkolonialistisch, postkolonial wiedergeben.\n'''\nkeyword = \"\" #z.B. \"postkol\"\n\n'''\nEinzufügen ist der Name des Dateiordners, \nder die zu analysierenden txt-Dateien enthält.\n'''\nfolder = \"\" #z.B. stopwordfiltered_by_year\n\n\n'''\nAnlegen einer leeren Liste, \nin der die im Weiteren erstellten Dictionaries gesammelt werden.\n'''\nlist_dict_keyword = []\n\n'''\nJede im Dateiordner vorliegende txt-Datei wird nacheinander eingelesen\nund die Texte zur besseren Vergleichbarkeit vollständig in Kleinbuchstaben umgewandelt.\n'''\nfor file in glob.glob(os.path.join(f\"{folder}\", \"*.txt\")):\n    with open(file, \"r\", encoding=\"utf-8\") as infile:\n        text_keyword = infile.read().lower()\n        \n        '''\n        Jeder Text wird von einem String in eine Wortliste umgewandelt, \n        wobei die Wörter an den Nicht-Wortzeichen gesplittet werden.\n        '''\n        text_keyword_list = re.split(\"\\W+\", text_keyword)\n\n        '''\n        Erstellen eines Dictionary für jeden Text.\n        Hierzu wird über die Wortliste eines jeden Textes iteriert \n        und die gefundenen Suchbegriffe als keys dem Dictionary hinzugefügt.\n        Bei erstmaligem Vorkommen erhält der Suchbegriff 1 als value.\n        Taucht der Suchbegriff mehrfach im Text auf, \n        wird der value für jedes Vorkommen hochgezählt.\n        '''\n        keyword_dict = {}\n        for i in text_keyword_list:\n                if i in keyword_dict:\n                    keyword_dict[i] +=1\n                else:\n                    keyword_dict[i] = 1\n        \n        '''\n        Aus den für die einzelnen Texte erstellen Dictionaries \n        werden nur die Wörter ausgewählt, \n        die mit dem als keyword ausgewählten Suchbegriff beginnen.\n        '''\n        keyword_dict = {k: v for k, v in keyword_dict.items() if k.startswith(keyword)}\n        \n        '''\n        Die für jeden Text entstandenen Dictionaries werden einer Liste hinzugefügt.\n        '''\n        list_dict_keyword.append(keyword_dict)\n\n'''\nDie in der Liste gesammelten einzelnen Dictionaries \nwerden gemäß ihres keys (=der gefundenen Wortform) \nin einem gemeinsamen Dictionary zusammengefügt, \nwobei die Anzahl des Vorkommens der Wortform (= value des Dictionaries) \nin den einzelnen Texten zuerst als Liste gespeichert wird.\n'''\nkeyword_dict_complete = {\n    k: [d.get(k) for d in list_dict_keyword if k in d]\n    for k in set().union(*list_dict_keyword)\n}\n\n'''\nDie in den values des Dictionary als Liste gespeicherten \nEinzelwerte des Vorkommens der einzelnen Wortformen werden summiert.\n'''\nfor k,v in keyword_dict_complete.items():\n    keyword_dict_complete[k] = sum(v)\n\n'''\nDas Dictionary wird absteigend nach der Höhe der values sortiert \n(die häufigst vorkommenden Wortformen werden an den Anfang gestellt).\n'''\nkeyword_dict_complete = {k: v for k, v in sorted(keyword_dict_complete.items(), key=lambda item: item[1], reverse=True)}\n\n'''\nDas Dictionary wird in einen Dataframe überführt \nund das Ergebnis abschließend in einer csv-Datei gespeichert.\n'''\ndf_keyword = pd.DataFrame.from_dict(keyword_dict_complete, orient='index', columns=[\"Häufigkeit\"])\ndf_keyword.to_csv(f\"{keyword}_einzelformen.csv\")\n\nDas Ergebnis dieser Analyse lässt sich auch durch Nutzung des Ergebnis-Dictionary keyword_dict_complete und der Python-Library WordCloud in einer Wortwolke darstellen. Für die Funktionalitäten von WordCloud siehe auch https://www.python-lernen.de/wordcloud-erstellen-python.htm. Generell bietet sich diese Form der Visualisierung für verschiedene hier durchgeführte Textanalyseschritte an.\n\n''' \nErstellen der WordCloud und Speichern als png\n'''\nwc = WordCloud(width=800, height=400, background_color='white').generate_from_frequencies(keyword_dict_complete)\nplt.figure(figsize=(15, 5))\nplt.imshow(wc, interpolation='bilinear')\nplt.axis('off')\nplt.savefig(f\"{keyword}_wortwolke.png\", facecolor='k', bbox_inches='tight')\n\n\n\nIdentifizierung von Einzeltexten, die einen Suchbegriff enthalten \nDas nachfolgende Skript soll die Möglichkeit bieten, die Anzahl und die Namen von Einzeltexten herauszufiltern, die einen bestimmten Suchbegriff enthalten. Während die vorangehenden Analyseschritte darauf basieren, dass die Texte nach Jahren gruppiert werden, um eine sinnvolle Auswertung zu ermöglichen, muss das nachfolgende Skript auf den aus media/rep/ extrahierten Einzeltexten ausgeführt werden. Hierzu ist prinzipiell keine Vorbearbeitung der Texte notwendig, es muss jedoch mit einer längeren Durchlaufzeit des Skriptes gerechnet werden (ca. 4-6 Minuten). Möchte man die Durchlaufzeit des Skriptes beschleunigen, kann das oben beschriebene Filtern von Stoppwörtern auch auf den Einzeldateien durchgeführt werden, was allerdings ebenfalls einen gewissen Zeitaufwand mit sich bringt.\nDie nachfolgende Analyse stützt sich auf absolute im Gegensatz zu relativen Zahlen. Dies bedeutet, dass die Häufigkeit des Vorkommens des Suchbegriffes in einem Text nicht in Bezug zur Gesamtanzahl der Wörter des Textes gesetzt wird. Die Nutzung des Skriptes bietet sich an, wenn man gezielt nach Publikationen zu einem bestimmten Begriff sucht.\nDas Skript sieht die Suche nach einem einzelnen Begriff vor und nicht die Suche nach mehreren Begriffen auf einmal. Hierzu müsste das Skript mehrmals hintereinander mit jeweils einem neuen Suchbegriff durchlaufen werden.\n\n'''\nEingabe des Suchbegriffes, \nfür den das Vorkommen in Einzeltexten ermittelt wird.\nMit dieser Suche kann nicht nur nach vollständigen Wörtern gesucht werden. \nEs werden auch Wörter wiedergegeben, \ndie mit dem eingegegeben Suchbegriff beginnen, \naber unterschiedliche Endungen aufweisen \nBeispiel:\nFür \"digital\" wird auch \"digitalität\", \"digitales\", \"digitally\" wiedergegeben.\n''' \nkeyword_singletexts = \"\" #z.B. \"virtuell\"\n\n'''\nEinzufügen ist der Name des Dateiordners, \nder die zu analysierenden txt-Dateien enthält. \nIn diesem Ordner müssen die aus media/rep/ extrahierten Einzeldateien vorliegen\nund keine nach Jahren gruppierten Texten.\n'''\nfolder = \"\" #z.B. \"fulltext\"\n\n\n'''\nAnlegen eines leeren Dataframe, \num die Ergebnisse der Häufigkeitsermittlung festzuhalten.\n'''\ndf_singletexts = pd.DataFrame()\n\n'''\nAnlegen einer leeren Liste, \nin der die Namen der Einzeltexte gespeichert werden, \ndie als Index des erstellten Dataframe fungieren.\n'''\nfilename_singletexts_list =  []\n\n'''\nAnlegen einer leeren Liste, \nin der die im Weiteren erstellten Dictionaries gesammelt werden.\n'''\nlist_singletexts_keyword = []\n\n'''\nJede im Dateiordner vorliegende txt-Datei wird nacheinander eingelesen \nund die Texte zur besseren Vergleichbarkeit \nvollständig in Kleinbuchstaben umgewandelt.\n'''\nfor file in glob.glob(os.path.join(f\"{folder}\", \"*.txt\")):\n    with open(file, \"r\", encoding=\"utf-8\") as infile:\n        text_singletexts = infile.read().lower()\n\n        '''\n        Jeder Text wird von einem String in eine Wortliste umgewandelt, \n        wobei die Wörter an den Nicht-Wortzeichen gesplittet werden.\n        '''\n        text_singletexts_list = re.split(\"\\W+\", text_singletexts)\n\n        '''\n        Die Dateinamen der eingelesenen Texte \n        werden auf ihren Kernnamen reduziert \n        (Dateierweiterung, Dateipfad wird entfernt) \n        und in einer Liste gesammelt, \n        die im Weiteren den Index des Dataframes darstellt.\n        '''\n        filename_singletexts = Path(file).stem\n        filename_singletexts_list.append(filename_singletexts)\n\n        '''\n        Erstellen eines Dictionary für jeden Text.\n        Hierzu wird über die Wortliste eines jeden Textes iteriert \n        und die gefundenen Suchbegriffe als keys dem Dictionary hinzugefügt.\n        Bei erstmaligem Vorkommen erhält der Suchbegriff 1 als value.\n        Taucht der Suchbegriff mehrfach im Text auf, \n        wird der value für jedes Vorkommen hochgezählt.\n        '''\n        singletexts_dict = {}\n        for i in text_singletexts_list:\n                if i in singletexts_dict:\n                    singletexts_dict[i] +=1\n                else:\n                    singletexts_dict[i] = 1\n        \n        '''\n        Aus den für die einzelnen Texte erstellen Dictionaries \n        werden nur die Wörter ausgewählt, \n        die mit den als keywords eingetragenen Suchbegriffen beginnen.\n        Die Anzahl des Vorkommens der einzelnen Wortformen und -kombinationen \n        zu einem Suchbegriff wird addiert. \n        Das Ergebnis wird einer Liste hinzugefügt.\n        '''\n        keyword_singletexts_dict = {k: v for k, v in singletexts_dict.items() if k.startswith(keyword_singletexts)}\n        list_singletexts_keyword.append(sum(keyword_singletexts_dict.values()))\n\n'''\nDie Ergebnisse aus dem Dictionary sowie die Anzahl der Wörter pro Text \nwerden in den Dataframe eingefügt.\n'''\ndf_singletexts.index = filename_singletexts_list\ndf_singletexts[keyword_singletexts] = list_singletexts_keyword\n\n'''\nAusgabe der Anzahl der Texte des Gesamtkorpus, \ndie den Suchbegriff enthalten, sowie den Prozentanteil, \nden diese Texte vom Gesamtkorpus ausmachen.\n'''\ntext_with_content = len(list_singletexts_keyword) - list_singletexts_keyword.count(0)\npercent_content = round(text_with_content / len(list_singletexts_keyword) * 100, 2)\nprint(f\"Anzahl der Texte, die den Suchbegriff '{keyword_singletexts}' enthalten: {text_with_content} (in Prozent: {percent_content}%) \\n\")\n\n'''\nGibt die 10 häufigsten Textnamen \nund die Häufigkeit der Nennung in absoluten Zahlen der Texte aus, \ndie den Suchbegriff am häufigsten enthalten\n'''\nprint(f\"Nachfolgend sind die 10 Texte gelistet, in denen der Suchbegriff '{keyword_singletexts}' in absoluten Zahlen am häufigsten vorkommt: \\n\")\n\nprint(df_singletexts[keyword_singletexts].nlargest(10).to_string())"
  },
  {
    "objectID": "datenvisualisieren.html",
    "href": "datenvisualisieren.html",
    "title": "Daten visualisieren mit RAWGraphs",
    "section": "",
    "text": "Download des für RAWGraphs aufgearbeiteten Datensatzes\nDiese Lecture-Einheit zielt darauf ab, die in unserem Übungsdatensatz enthaltenen Daten in verschiedenen Typen von Diagrammen graphisch darzustellen. Hierzu werden wir uns zuerst mit der Frage beschäftigen, was eine gute graphische Darstellung ausmacht und worauf generell bei der Erstellung von Datenvisualisierungen geachtet werden sollte. Mithilfe des Web-Tools RAWGraphs, dessen Funktionalitäten wir an ein paar Beispielen erklären, werden wir dann bezogen auf unseren Datensatz verschiedene Diagramme erstellen."
  },
  {
    "objectID": "datenvisualisieren.html#was-ist-rawgraphs",
    "href": "datenvisualisieren.html#was-ist-rawgraphs",
    "title": "Daten visualisieren mit RAWGraphs",
    "section": "Was ist RAWGraphs?",
    "text": "Was ist RAWGraphs?\n\nFunktion: Man kann eine Datentabelle hochladen, um aus den Daten Visualisierungen in Form von Diagrammen zu erstellen (Balkendiagramme, Kurvendiagramme, Tortendiagramme etc.)\nOpen Source Tool, kann kostenfrei genutzt werden\nkeine Installation notwendig, kann als Web-App im Browser benutzt werden\nkeine Programmierkenntnisse notwendig\nAlternative zu Tools wie Excel, Tableau und Programmiersprachen wie Python und R, mithilfe derer ebenfalls Visualisierungen hergestellt werden können"
  },
  {
    "objectID": "datenvisualisieren.html#wie-ist-rawgraphs-zu-benutzen",
    "href": "datenvisualisieren.html#wie-ist-rawgraphs-zu-benutzen",
    "title": "Daten visualisieren mit RAWGraphs",
    "section": "Wie ist RAWGraphs zu benutzen?",
    "text": "Wie ist RAWGraphs zu benutzen?\n\nRAWGraphs bietet Beschreibungen und Tutorials über die Funktionalitäten des Tools und die Erstellung bestimmter Diagrammtypen an: RAWGraphs Tutorials (auf Englisch)\nZudem sind hier Beschreibungen für die Erstellung von Diagrammtypen zu finden, die im Rahmen des DiCi-Hub-Projekts erstellt wurden\n\n\nHochladen von Datentabellen\n\n\n\n\n\nEs gibt verschiedene Optionen, Daten in RAWGraphs einzufügen/hochzuladen. Es können Daten im Format tsv, csv und dsv sowie JSON genutzt werden.\n\nPaste your data: Hier kann eine Tabelle (z.B. aus Excel) kopiert und eingefügt werden. Dies ist nur bei kleinen Tabellen ratsam, da die Gefahr eines Datenverlusts inbesondere bei komplexen Datentabellen bei Copy und Paste recht hoch ist. Es muss darauf geachtet werden, dass die Daten den oben genannten Formaten entsprechen. Eine Tabelle aus einem Textverarbeitungsprogramm wie Word kann hier nicht einfach eingefügt werden.\nUpload your data: Hier kann eine lokal gespeicherte Datentabelle hochgeladen werden. Dieser Weg ist generell zu empfehlen, da er weniger fehleranfällig ist.\nTry our data samples: RAWGraphs bietet für fast alle Diagrammtypen Beispieldatensätze zu Übungszwecken an. Dies ist ein guter Einsteig um die Funktionen von RAWGraphs kennen zu lernen.\nSPARQL query und From URL: Hier besteht die Möglichkeit, Daten über eine SPARQL-Abfrage (z.B. über Wikidata) einzufügen oder diese direkt von einer Webseite abzurufen. Das erfordert jedoch Zusatzkenntnisse.\nOpen your project: Hier besteht die Möglichkeit, ein eigenes RAWGraphs-Projekt hochzuladen. Wenn man mit der Erstellung einer Visualisierung begonnen hat und diese zu einem späteren Zeitpunkt weiter bearbeiten möchte, kann diese über die Exportfunktion (s.u.) lokal gespeichert werden.\n\n\n\nTabelleneinstellungen\n\n\n\n\n\nRAWGraphs bietet nicht viele Optionen, das Format der Tabelle zu verändern. Die Inhalte müssen bereits vor Einfügen in ihrem finalen Zustand vorliegen. Es gibt aber folgende Optionen die Formatierung und Inhalte zu beeinflussen:\nData Parsing Options\n\nColumn separator: Im Normalfall erkennt RAWGraphs den korrekten Separator einer Tabelle, durch den die einzelnen Spalten definiert sind, automatisch. Sollte es hier jedoch zu einem Fehler kommen, kann manuell eingestellt werden, ob es sich um ein Komma, einen Tab, ein Semikolon oder einen Pipe-Strich (|) handelt.\nThousands separator und Decimal separator: Hier lässt sich für die Datentabelle einstellen, ob die Tausender- oder Dezimalstellen einer Zahl durch Komma oder Punkt gekennzeichnet sind.\nDate Locale: Hier lassen sich verschiedene länderspezifische Datumsformate einstellen.\n\nData Transformation\n\nStack on: Über dieses Feld lässt sich die Datenstruktur der Tabelle von einer zeilenorientierten in eine spaltenorientierte Form oder andersherum bringen. Eine genaue Erklärung hierzu findet sich unter folgendem Link: “Meet the unpivoter”. Da diese grundlegende Veränderung der Datenstruktur oft schwer umzusetzen ist, ist es meist ratsam, die Datenstruktur bereits im Vorfeld vor Hochladen in RAWGraphs in das richtige Format zu bringen.\nReset: Löscht die hochgeladene Datentabelle und alle bei den Visualisierungen gemachten Einstellungen und gibt die Möglichkeit, einen neuen Datensatz hochzuladen.\nChange data: Hat man bereits eine Visualisierung erstellt und möchte genau in diesem Format eine weitere Visualisierung mit einem anderen Datensatz erstellen, kann über diese Funktion der weitere Datensatz hochgeladen werden. Alle anderen Einstellungen bleiben erhalten. Dieser weitere Datensatz muss aber in exakt derselben Struktur wie der erste Datensatz vorliegen.\n\n\n\nBearbeiten des Datenformats\nDurch Anklicken des runden Feldes neben dem Namen der Spalte öffnet sich eine Drop-Down-Liste, mithilfe derer das Datenformat der Spalte verändert werden kann.\n\n\n\n\n\n\n\nChoose a chart and Mapping\nRAWGraphs stellt für jeden Diagrammtyp ein ca. anderthalb Minuten langes Tutorial zur Verfügung. Gleichzeitig können zur Entscheidung, welcher Diagrammtyp genutzt werden sollte und wie mit dem Mapping umgegangen werden muss, die hier zur Verfügung gestellten Beschreibungen für die Erstellung von Diagrammtypen herangezogen werden.\nEine weitere Quelle, die einen Überblick über Diagrammtypen und ihre Verwendung bietet, sind die online verfügbaren Artikel “How to Choose the Right Data Visualization” oder “A Tour through the Visualization Zoo”. (Stand Oktober 2023)\nBeim Mapping werden die Dimensions per Drag&Drop auf die Felder der Chart Variables gezogen. Die mit einem roten Sternchen gekennzeichneten Felder sind verpflichtende Angaben, alle weiteren sind optional.\n\n\n\n\n\nEine Besonderheit beim Mapping stellt zudem die Option der Aggregation von Werten dar. Aggregation von Werten ist nur bei einigen Variablen möglich, und zwar sind dies “Size”, “Color” and “Labels”. RAWGraphs wählt automatisch eine Aggregationsmöglichkeit aus, über ein Drop-Down-Feld lässt sich dies aber anpassen.\n\n\n\n\n\nAnhand einer konstruierten Beispieltabelle sollen die verschiedenen Aggregationsmöglichkeiten kurz vorgestellt werden:\n\n\n\nTier\nAnzahl\n\n\n\n\nKatze\n15\n\n\nHund\n12\n\n\nKaninchen\n9\n\n\nWellensittich\n3\n\n\nKatze\n22\n\n\nHund\n17\n\n\nKaninchen\n15\n\n\nKatze\n32\n\n\n\nWürde man diese Tabelle in RAWGraphs einfügen und daraus ein Balkendiagramm erstellen wollen:\n\ncount und count unique: Hier wird die Wertespalte der Tabelle (also in diesem Fall die Spalte “Anzahl”) nicht berücksichtigt, sondern gezählt, wie oft eine Kategorie in der Spalte Tier vorkommt. In einem Balkendiagramm wäre der Balken für die Katze damit 3 Einheiten hoch, während die Balken für die anderen Tiere jeweils 2 Einheiten hoch wären. Prinzipiell würde die Funktion count unique dagegen jede Kategorie nur einmal zählen, um eine Auflistung zu bekommen, welche Kategorien in der Tabelle vorhanden sind. Bei unserer Arbeit mit RAWGraphs hat diese Funktion jedoch in keinem Kontext bisher funktioniert und wäre vermutlich auch für die Erstellung eines Diagramms nur schlecht zu nutzen.\naverage: Hiermit wird ein Durchschnittswert ermittelt. In Bezug auf die Katze wäre der Durchschnittswert 23 ((15+22+32)÷3). Dieser könnte ebenfalls in einem Balkendiagramm als Balkenhöhe angegeben werden.\nmax: Hier werden nur die Maximalwerte angegeben. Dies würde bedeuten, dass aus der oben genannten Tabelle in einem Balkendiagramm der Balken für die Katze 32 Einheiten hoch wäre, für den Hund 17, das Kaninchen 15 und den Wellensittich 3.\nmin: Hier werden nur die Minimalwerte angegeben. Dies würde bedeuten, dass aus der oben genannten Tabelle in einem Balkendiagramm der Balken für die Katze 15 Einheiten hoch wäre, für den Hund 12, das Kaninchen 9 und den Wellensittich 3.\nsum: Hiermit werden Werte derselben Kategorie summiert. Für Kaninchen würde sich also mit der oben genannten Tabelle die Summe von 24 ergeben. Beispielsweise wäre der Balken in einem Balkendiagramm dann 24 Einheiten hoch.\nmedian: Hier wird der Median gebildet. Der Median ist der Wert, der genau in der Mitte einer Datenverteilung liegt, auch Zentralwert genannt. Dies lässt sich anhand der oben genannten Tabelle nicht gut darstellen, daher hier ein anderes Beispiel. Es gibt eine Wertereihe von 1 7 16 18 32 96 102. Darin ist der Median 18, also der Wert, der genau in der Mitte der Zahlenreihe liegt. Als Vergleich: Der Durchschnittswert liegt dagegen bei 38,857.\ncsv und csv unique: Bei unserer Arbeit mit RAWGraphs ist uns diese Form der Aggregation bisher nur in Zusammenhang mit hierarchischen Diagrammen begegnet (z.B. Treemap, Circular Packing) für die Farbeinteilung (Color) oder das Anzeigen von Labels, wobei es sich in diesen Kontexten dann nicht um eine typische Aggregation handelt, sondern es um Werte in Wortform geht.\n\n\n\nAnpassen der Größe der Graphik\n\n\n\n\n\n\nWidth und Height: Hier lässt sich die Gesamtgröße der Graphik einstellen.\nBackground: Hier lässt sich eine Hintergrundfarbe für die Graphik auswählen.\nMargin: Hier kann eingestellt werden, wie viel “weiße Fläche” rund um das eigentliche Diagramm dargestellt werden soll. Dies kann optisch schöner sein, es hat aber auch praktische Zwecke, wenn das Diagramm längere Beschriftungen aufweist, die ohne Zusatzrand abgeschnitten würden.\n\n\n\nAnpassen von Farben und Beschriftungen\nDie in den Abschnitten Chart, Colors, Labels möglichen Einstellungen variieren z.T. zwischen den Diagrammtypen. Ein Farbschema ist letztlich leicht auswählbar, da vorgefertigte Sets von Farben angeboten werden. Eine eigene Farbzusammenstellung ist allerdings nicht möglich. Auch ist leicht einstellbar, ob Labels innerhalb des Diagramms angezeigt werden sollen oder nicht.\nEinzelne Beschreibungen zu der Rubrik Chart finden sich in den jeweiligen Tutorials zu den Diagrammtypen in RAWGraphs und den hier vorgestellten Erklärungen zu den einzelnen Diagrammtypen.\n\n\n\n\n\nFür einige Diagrammtypen (z.B. Bar chart, Line chart, Bumpchart) besteht zudem die Möglichkeit eine Serie (Series) anzulegen. Hierzu werden mehrere Diagramme erstellt, wobei jedes Diagramm beispielsweise Daten aus einem einzelnen Jahr oder verschiedenen einzelnen Ländern repräsentiert. Man kann dabei selbst bestimmen, in wie vielen Spalten die einzelnen Diagramme nebeneinander angeordnet werden und ob für jedes Diagramm eine eigene Achse angezeigt wird oder möglicherweise sogar unterschiedliche Skalen für die Diagramme benutzt werden. Bei unterschiedlichen Skalen stellt sich jedoch die Frage, ob sich die einzelnen Diagramme noch sinnvoll vergleichen lassen.\n\n\nExport eines Diagramms\nEin erstelltes Diagramm kann in den gängingen Graphikformaten exportiert werden (jpg, png, svg). Des Weiteren besteht die Möglichkeit eine .rawgraphs-Datei zu erstellen, die dann erneut in RAWGraphs geöffnet und weiterbearbeitet werden kann."
  },
  {
    "objectID": "datenvisualisieren.html#was-ist-allgemein-bei-der-benutzung-von-rawgraphs-zu-beachten",
    "href": "datenvisualisieren.html#was-ist-allgemein-bei-der-benutzung-von-rawgraphs-zu-beachten",
    "title": "Daten visualisieren mit RAWGraphs",
    "section": "Was ist allgemein bei der Benutzung von RAWGraphs zu beachten?",
    "text": "Was ist allgemein bei der Benutzung von RAWGraphs zu beachten?\n\nes gibt nur wenige Möglichkeiten, Tabellen umzuformatieren; Daten müssen schon vorher bereinigt sein\n\nes darf keine eine leeren Zellen geben, jede Zeile/Spalte muss komplett ausgefüllt sein\n\nbei Zahlen mit Maßangaben darauf achten, dass die Maßangabe (also der Textteil) entfernt wird, ansonsten wird die Zahl nicht korrekt erkannt\n\nin jeder Zelle darf nur genau ein Wert stehen, mehrere Werte in einer Zelle können nicht verarbeitet / erkannt werden\n\nbei der Auswahl eines geeigneten Diagrammtyps und der Vorformatierung der Tabelle hilft es tendenziell eher in Spalten als in Zeilen zu denken\n\ninsbesondere die Beschriftung der erstellten Diagramme kann in RAWGraphs nur bedingt verändert werden; die Beschriftung orientiert sich automatisch an den Angaben in der Datentabelle; generell können in RAWGraphs erstellte Diagramme in anderen Bearbeitungsprogrammen für Graphiken nachbearbeitet werden\n\nein mit RAWGraphs erstelltes Diagramm muss nicht zwangsweise als „mit RAWGraphs hergestellt“ gekennzeichnet werden; es wird allerdings eine Zitiermöglichkeit von RAWGraphs geboten"
  },
  {
    "objectID": "datenvisualisieren.html#was-macht-eine-gute-visualisierung-aus",
    "href": "datenvisualisieren.html#was-macht-eine-gute-visualisierung-aus",
    "title": "Daten visualisieren mit RAWGraphs",
    "section": "Was macht eine gute Visualisierung aus?",
    "text": "Was macht eine gute Visualisierung aus?\nAlberto Cairo hat fünf Kriterien einer guten Visualisierung definiert (siehe dazu ausführlich beispielsweise die Materialien des “UMSL Data-Viz-Workshops-2021” oder Rehbein, M. (2017). Informationsvisualisierung. In: Jannidis, F., Kohle, H., Rehbein, M. (eds) Digital Humanities. J.B. Metzler, Stuttgart.)\n\ntruthful (Daten müssen korrekt sein)\n\nfunctional (Darstellung soll eine bestimmte Funktion erfüllen)\n\nbeautiful (Darstellung soll ästhetisch ansprechend sein)\n\ninsightful (Darstellung soll einen guten Einblick in die Daten ermöglichen)\n\nenlightening (Darstellung sollte den Wissensstand erweitern)\n\nBeispiele für gute und schlechte Visualisierungen sind zudem in der “Datavis Gallery” und in einem von der University of Auckland bereitgestellten PDF Statistics 120 Good and Bad Graphs zu finden.\nDie Screenshots wurden von Theresa Blaschke erstellt. Zuletzt bearbeitet am 14.11.2023"
  },
  {
    "objectID": "datenbereinigen.html",
    "href": "datenbereinigen.html",
    "title": "Daten bereinigen und anreichern mit OpenRefine",
    "section": "",
    "text": "Diese Lecture-Einheit zielt darauf ab, unseren Übungsdatensatz weiter zu explorieren sowie Unregelmäßigkeiten schnell zu erkennen und zu vereinheitlichen. Hierzu stellen wir das freie Programm OpenRefine vor und zeigen anhand unseres Übungsdatensatzes die Grundfunktionen. Neben der Datenbereinigung gehen wir auf die Datenanreicherung mit OpenRefine aus externen Datenquellen wie WikiData ein."
  },
  {
    "objectID": "datenbereinigen.html#was-ist-openrefine",
    "href": "datenbereinigen.html#was-ist-openrefine",
    "title": "Daten bereinigen und anreichern mit OpenRefine",
    "section": "Was ist OpenRefine?",
    "text": "Was ist OpenRefine?\n\nFunktion: OpenRefine ist ein Werkzeug, das unter anderem dazu geeignet ist, um einen Überblick über Datensätze zu erhalten, sie zu bereinigen, mit externen Daten anzureichern oder in andere Formate zu exportieren. Hierfür wird ein Datensatz in das Programm geladen.\nOpen Source Tool, kann kostenfrei genutzt werden, verfügbar für Windows, Linux und Mac OS\nEs sind keine Programmierkenntnisse notwendig, jedoch sind für die fortgeschrittene Nutzung Kenntnisse einer Programmiersprache, regulärer Ausdrücke und zur Datenbankabfrage von Vorteil.\nAlternative zu Tools wie Excel und Programmiersprachen wie Python und R, mithilfe derer ebenfalls Daten bereinigt werden können."
  },
  {
    "objectID": "datenbereinigen.html#installation",
    "href": "datenbereinigen.html#installation",
    "title": "Daten bereinigen und anreichern mit OpenRefine",
    "section": "Installation",
    "text": "Installation\nEs erfolgt keine Installation im klassischen Sinne. Das Programm kann für das eigene Betriebssystem von der Webseite heruntergeladen werden. Im Fall von Windows sollte geprüft werden, ob die Version mit oder ohne der Programmiersprache Java benötigt wird. Der Download besteht aus einem komprimierten Ordner. In komprimierten Ordnern können mehrere Dateien bereitgestellt oder verschickt werden und die Größe der einzelnen Dateien ist kleiner. Der heruntergeladene Ordner muss, damit OpenRefine ausgeführt werden kann, dekomprimiert werden. Das erfolgt in den meisten Fällen, dass man mit der rechten Maustaste auf den Ordner klickt und im Menü “entpacken” auswählt. Der Begriff “entzippen” ist ebenfalls gängig."
  },
  {
    "objectID": "datenbereinigen.html#openrefine---grundfunktionen",
    "href": "datenbereinigen.html#openrefine---grundfunktionen",
    "title": "Daten bereinigen und anreichern mit OpenRefine",
    "section": "OpenRefine - Grundfunktionen",
    "text": "OpenRefine - Grundfunktionen\nWenn OpenRefine gestartet wird, öffnen sich zwei Fenster: ein Terminalfenster und ein neuer Tab im Standardbrowser. Beide Fenster werden benötigt, damit das Programm läuft, sie dürfen nicht geschlossen werden. Im Terminal werden die einzelnen Arbeitsschritte im Programm angezeigt. Im Browserfenster wird mit dem Programm interagiert.\n\n\nEin Projekt erstellen\nDas Öffnen eines Datensatzes, der lokal vorliegt, erfolgt unter dem voreingestellten Menü “Create project” (linke Spalte). Der Datensatz kann mit “Durchsuchen” ausgewählt werden. Mit “Next” wird der Vorgang bestätigt.\n\nEs öffnet sich die Vorschau des Datensatzes. In dieser kann geprüft werden, ob die Daten korrekt eingelesen werden. Unter der Vorschau kann unter “CSV/TSV/seperator-based files” geprüft werden, ob das sogenannte “Character Encoding” korrekt ist (unter anderem relevant für die Darstellung von Umlauten) und Trennzeichen korrekt angegeben werden (in unserem Fall ein Komma). Außerdem können der Name des Projektes sowie Schlagwörter vergeben werden. Mit Schlagwörtern können Projekte bei Bedarf besser organisiert werden. Wenn alle Einstellungen korrekt sind, kann rechts oben “Create project” bestätigt werden.\n\nNachdem das Projekt gestartet wurde, werden euch nur 10 Zeilen angezeigt. Das entspricht der Standardeinstellung. Die Anzahl der angzeigten Zeilen kann über dem Datensatz angepasst werden:\n\n\n\nIm Projekt arbeiten\nDie Grundfunktionen werden in der Regel über das kleine Dreieck in jedem Spaltenkopf aufgerufen, da der Datensatz meist spaltenweise bearbeitet wird. Im Untermenü, das sich bei Anklicken öffnet, besteht eine Reihe an Aktionsmöglichkeiten. Der Verlauf der einzelnen Aktionsmöglichkeiten ist in der linken Seitenspalte des Programms aufgeführt, sodass jederzeit einzelne Aktionen rückgängig gemacht werden können. Außerdem öffnet sich in der Seitenspalte bei einigen Aktionen ein Fenster, über das weitere Optionen zur Verfügung stehen bzw. Ergebnisse angezeigt werden. Im Folgenden wird nur ein winziger Ausschnitt gezeigt.\n\nIm Kontextmenü der Spalten kann beispielsweise unter “Edit column” die Spalte_voller_Unsinn gelöscht werden.\n\nAußerdem können in diesem Menü auch Spalten mit mehreren Einträgen wie OMDb_Actors aufgesplittet werden, sodass jeder Schauspielerin in einer eigenen Spalte steht. Dazu müssen die Trennzeichen eingegeben werden:\n\nEine praktische Funktion, um sich einen Überblick über die Einträge einer Spalte zu verschaffen, ist die Funktion “Facet”. Am Beispiel der Spalte OMDb_Country bietet sich “Text facet” an, da die Werte in der Spalte Text enthalten.\n\nDie Spalte bleibt unverändert. In der linken Seitenspalte erscheint ein Fenster, in dem die Erbegnisse der Funktion angezeigt werden: Im Fenster wird angezeigt, dass es 58 verschiedenen Angaben zu den Ländern in der Spalte gibt. Die Zahl hinter den Ländern gibt an, wie oft sie eingtragen sind. Die Anzeige kann alphabetisch oder nach Häufigkeit sortiert werden. Um einen Überblick über ähnliche Einträge zu erhalten, kann die “Cluster”-Funktion ausgewählt werden. Diese ist insbesondere praktisch, wenn Rechtschreibfehler oder Inkonsistenzen im Datensatz sichtbar sind oder vermutet werden, da hier mit verschiedenen Algorithmen ebenjene geprüft werden. Es öffnet sich ein neues Fenster:\n\nEs wird angezeigt, welche Inkonsistenzen gefunden wurden. Hier handelt es sich um die Reihenfolge der Länder. Es wird angegeben wie viele ähnliche Einträge zu einem Cluster gehören, in wie vielen Zeilen sie gefunden wurden und es wird ein Vorschlag zur Vereinheitlichung angegeben, dem gefolgt werden kann, sofern kein eigener Vorschlag eingetragen werden soll. Die Einträge können gemerged werden, d.h. dass sie vereinheitlicht werden und dann entsprechend nur noch eine Variante der Reihenfolge im Datensatz angezeigt wird. Vor dem mergen sollte geprüft werden, ob es aus fachlicher Perspektive sinnvoll ist!\nEinzelne Fehler können auch direkt in den Zellen korrigiert werden. Wenn sich die Maus über einer Zelle befindet, wird die Option “Edit” eingeblendet."
  },
  {
    "objectID": "datenbereinigen.html#openrefine---daten-anreichern",
    "href": "datenbereinigen.html#openrefine---daten-anreichern",
    "title": "Daten bereinigen und anreichern mit OpenRefine",
    "section": "OpenRefine - Daten anreichern",
    "text": "OpenRefine - Daten anreichern\nEine sehr mächtige Information von OpenRefine ist “Reconcile”. Mithilfe dieser Funktion kann der eigene Datensatz mit Daten aus externen Quellen angereichert werden. OpenRefine bietet integriert beispielsweise die automatisierte Anreicherung mit Daten von WikiData an, die im Folgenden gezeigt wird. Eine Anreicherung mit weiteren Daten kann sinnvoll sein, wenn Normdaten benötigt werden oder weitere Informationen, die noch nicht im Datensatz stehen. Wir arbeiten wieder an der Spalte OMDb_Country und wählen die letzte Option “Reconcile” und “Start Reconciling” aus. Es öffnet sich ein Fenster, in dem Wikidata als externe Quelle ausgewählt wird und können nun weitere Einstellungen vornehmen:\n\nAnhand der Einträge in der Spalte wird ein Vorschlag gemacht, welche Entitäten von Wikidata passen. Da es sich um Länder handelt, wird country gewählt. Das Häckchen bei “Auto-match” candidates with high confidence” kann so bestehen bleiben, da sonst alle Einträge händisch bestätigt werden müssen. Mit “Start reconciling” beginnt die Anreicherung, die unterschiedlich lange Zeit in Anspruch nehmen kann. Das Ergebnis sieht wiefolgt aus:\n\nIn der ersten Zeile ist eine Verbindung zum Eintrag “United States of America”, der direkt gematched wurde, weil die Entscheidung eindeutig war. In der zweiten und dritten Zeile sehen wir mehrere Optionen, aus denen wir auswählen können, da hier keine eindeutige Entscheidung möglich war. Die Vorschläge passen jedoch zum Ziel, Länder anzureichern, sondern beziehen sich in den Einträgen, in denen mehrere Länder stehen, auf Ereignisse, die beide Länder einbeziehen. D.h., an dieser Stelle ist ein Anwendungsfall für die Funktion “Undo”. Reconcile kann damit rückgängig gemacht werden, die Spalte gesplittet werden und die die einzelnen Spalten können dann angereichert werden. Hinweis: Bei der Auswahl der Entität von Wikidata, mit der angereichert werden soll, kann es erste Hinweise dafür geben, ob sich die Spalte für das eigene Anreicherungsziel eignet.\n\nHinweis zum Abschluss\nHier wurde nur die Spitze des Eisberges vorgestellt. Es gibt eine Vielzahl von weiteren Funktionen und Möglichkeiten, die in der Dokumentation oder in Foren erklärt werden.\nAlle Screenshots wurden von Frauke Pirk erstellt. Zuletzt bearbeitet am 07.11.2023"
  },
  {
    "objectID": "brunchlectures.html",
    "href": "brunchlectures.html",
    "title": "Brunch Lectures",
    "section": "",
    "text": "Diese dreiteilige Lecture-Reihe dient dazu, einen Einblick in das Arbeiten mit Datensätzen zu geben. Wir arbeiten über die drei Veranstaltungen hinweg an einem Datensatz, den wir zuvor bereitstellen. Die Veranstaltungen können unabhängig voneinander besucht werden.\nAnmeldung immer bis montags 14 Uhr unter dicihub@uni-marburg.de\n\n\n\n\n\n\n\n\nFür die Brunch-Lecture-Reihe wurde von uns ein Datensatz (zum Download anklicken) vorbereitet, der Daten zu einer Reihe von Filmen mit Angaben zu Regie, Genre, Sprache, Bewertungen und weiterem enthält. Der Originaldatensatz mit Hintergrundinformationen zu seiner Entstehung ist unter dem Namen Movie Lab auf der Online-Open-Source-Plattform Open Syllabus zu finden.\nBei dem Datensatz handelt es sich um eine Datei im csv-Format. CSV steht für Comma-Separated Values. Dieses Dateiformat hat den Vorteil, dass es sich mit einer Reihe unterschiedlicher Programme öffnen und bearbeiten lässt.\n\n\n\nFür jede Lecture-Einheit stellen wir begleitende Informationen zum Nachlesen und Nachnutzen zur Verfügung:\nDaten sortieren und filtern mit Excel\nDaten bereinigen und anreichern mit OpenRefine\nDaten visualisieren mit RAWGraphs\nZuletzt bearbeitet am 31.10.2023"
  },
  {
    "objectID": "brunchlectures.html#online-brunch-lectures",
    "href": "brunchlectures.html#online-brunch-lectures",
    "title": "Brunch Lectures",
    "section": "",
    "text": "Diese dreiteilige Lecture-Reihe dient dazu, einen Einblick in das Arbeiten mit Datensätzen zu geben. Wir arbeiten über die drei Veranstaltungen hinweg an einem Datensatz, den wir zuvor bereitstellen. Die Veranstaltungen können unabhängig voneinander besucht werden.\nAnmeldung immer bis montags 14 Uhr unter dicihub@uni-marburg.de\n\n\n\n\n\n\n\n\nFür die Brunch-Lecture-Reihe wurde von uns ein Datensatz (zum Download anklicken) vorbereitet, der Daten zu einer Reihe von Filmen mit Angaben zu Regie, Genre, Sprache, Bewertungen und weiterem enthält. Der Originaldatensatz mit Hintergrundinformationen zu seiner Entstehung ist unter dem Namen Movie Lab auf der Online-Open-Source-Plattform Open Syllabus zu finden.\nBei dem Datensatz handelt es sich um eine Datei im csv-Format. CSV steht für Comma-Separated Values. Dieses Dateiformat hat den Vorteil, dass es sich mit einer Reihe unterschiedlicher Programme öffnen und bearbeiten lässt.\n\n\n\nFür jede Lecture-Einheit stellen wir begleitende Informationen zum Nachlesen und Nachnutzen zur Verfügung:\nDaten sortieren und filtern mit Excel\nDaten bereinigen und anreichern mit OpenRefine\nDaten visualisieren mit RAWGraphs\nZuletzt bearbeitet am 31.10.2023"
  },
  {
    "objectID": "datensortieren.html",
    "href": "datensortieren.html",
    "title": "Daten sortieren und filtern mit Excel",
    "section": "",
    "text": "Diese Lecture-Einheit zielt darauf ab, unseren Übungsdatensatz und das csv-Format kennen zu lernen. Hierzu benutzen wir das Tabellenkalkulationsprogramm Excel. Wir schauen uns an, wie eine csv in Excel geöffnet und formatiert werden kann und zeigen grundlegende Excel-Funktion wie das Filtern und Sortieren von Daten."
  },
  {
    "objectID": "datensortieren.html#was-ist-excel",
    "href": "datensortieren.html#was-ist-excel",
    "title": "Daten sortieren und filtern mit Excel",
    "section": "Was ist Excel?",
    "text": "Was ist Excel?\nExcel ist ein kostenpflichtiges Tabellenkalkulationsprogramm von Microsoft. Es dient vor allem der Datenanalyse und -visualisierung und gilt als weltweit verbreitetstes Programm seiner Art.\nExcel ist tabellarisch aufgebaut, in\n\ndurchnummerierte Zeilen:\n\n\n\nund durchalphabetisierte Spalten:\n\n\nBei einem einzelnen Feld spricht man von einer Zelle.\nZellen können mittels Formeln zueinander in Relation gesetzt werden, zum Beispiel aufsummiert. Eine beliebte Anwendung von Excel ist darum im Rechnungswesen.\nDa sich die Höhe und Breite von Zellen automatisch und manuell variieren lassen, gibt es allerdings auch Beispiele für die Zweckentfremdung des Programms zur Herstellung von Pixel Art."
  },
  {
    "objectID": "datensortieren.html#installation",
    "href": "datensortieren.html#installation",
    "title": "Daten sortieren und filtern mit Excel",
    "section": "Installation",
    "text": "Installation\nAn den Unis Marburg, Mainz und Frankfurt gibt es jeweils Lizenzverträge, damit die Microsoft Office-Programme (inklusive Excel) von Universitätsangehörigen kostenlos genutzt werden können.\nDownloadanleitungen sollten jeweils unter folgenden Links zu finden sein:\nHochschulrechenzentrum der Uni Marburg:\nhttps://www.uni-marburg.de/de/hrz/dienste/software/microsoft_office\nZentrum für Datenverarbeitung der Uni Mainz:\nhttps://www.zdv.uni-mainz.de/jgu-signin-oidc/tag/lizenzen/\nHochschulrechenzentrum der Uni Frankfurt:\nhttps://www.rz.uni-frankfurt.de/73202101/Microsoft_Office_f%25C3%25BCr_Studierende\nAnsonsten kann auch eine kostenlose, aber zeitlich begrenzte Testversion verwendet werden: https://www.microsoft.com/de-de/microsoft-365/try?culture=de-de&country=de"
  },
  {
    "objectID": "datensortieren.html#download-des-beispieldatensatzes",
    "href": "datensortieren.html#download-des-beispieldatensatzes",
    "title": "Daten sortieren und filtern mit Excel",
    "section": "Download des Beispieldatensatzes",
    "text": "Download des Beispieldatensatzes\nDer Beispieldatensatz, mit dem wir im Rahmen aller drei Veranstaltungen arbeiten, findet sich unter folgendem Link zum Download.\nBei dem Datensatz handelt es sich um eine csv-Datei. CSV steht dabei für Comma-Separated Values. Dieses Dateiformat hat den Vorteil, dass es sich mit einer Reihe unterschiedlicher Programme öffnen und bearbeiten lässt."
  },
  {
    "objectID": "datensortieren.html#öffnen-einer-csv-datei-in-excel",
    "href": "datensortieren.html#öffnen-einer-csv-datei-in-excel",
    "title": "Daten sortieren und filtern mit Excel",
    "section": "Öffnen einer csv-Datei in Excel",
    "text": "Öffnen einer csv-Datei in Excel\nUm eine csv-Datei in Excel zu öffnen, kann man auf verschiedene Arten und Weisen vorgehen. Die hier vorgestellte Möglichkeit 1 wird allerdings gegenüber den anderen beiden empfohlen.\n\nMöglichkeit 1\n\nZuerst öffnet man Excel.\nDann wählt man oben den Reiter „Daten“ aus und klickt dort auf „Daten abrufen (Power Query)“.\n\n\n\nDaraufhin erscheint eine Übersicht an Optionen, von denen man „Text/CSV“ auswählt und anklickt.\n\n\n\nAnschließend durchsucht man seine Dateien nach dem gewünschten Datensatz (in diesem Fall unserem Beispieldatensatz).\n\n\n\nUnd klickt auf „Daten importieren“, um diesen in Excel zu öffnen.\n\n\n\nHat man die richtige Datei ausgewählt, klickt man unten auf „Weiter“.\n\n\n\nExcel präsentiert daraufhin eine Voransicht des Datensatzes.\n\n\n\nIst man mit den Einstellungen zufrieden, klickt man unten auf „Laden“.\nExcel importiert daraufhin die Daten aus der csv-Datei in Tabellenform, sodass direkt damit gearbeitet werden kann.\n\n\n\n\nMöglichkeit 2\n\nMan öffnet die CSV-Datei mit Excel im „.xlsx“-Format.\nDie Daten sind anschließend in Excel lesbar, allerdings noch nicht verarbeitbar, da sie nicht als Tabelle formatiert sind.\nUm die Daten als Tabelle zu formatieren klickt man unter dem Reiter „Start“ auf „Als Tabelle formatieren“.\nIn dem daraufhin erscheinenden Fenster überprüft man, ob der Datenbereich korrekt ist, und klickt anschließend auf „OK“.\n\n\n\nMöglichkeit 3\n\nPer Rechtsklick auf die CSV-Datei wählt man über die Option „Öffnen mit“ Excel aus.\n\n\n\nDie Daten werden hieraufhin in Excel importiert, allerdings werden dabei alle Daten in die erste Spalte gequetscht. Und es erscheint die Hinweisemeldung, dass eventuell nicht alle Daten korrekt importiert wurden.\n\n\n\nWer hier noch nicht aufgegeben hat, markiert per Klick auf Spalte A die gesamte Spalte und wählt anschließend unter dem Reiter „Daten“ die Funktion „Text in Spalten“ aus.\n\n\n\nIn dem auftauchenden Fenster wählt man die Option „Mit Trennzeichen versehen“ aus und klickt auf „Weiter“.\n\n\n\nDa es sich um eine CSV-Datei handelt, also um Comma-Separated Values, wählt man als Trennzeichen „Komma“ aus und klickt auf „Weiter“, wenn die Vorschau korrekt aussieht.\n\n\n\nIn einem zweiten Optionsfenster hat man anschließend die Möglichkeit einzelne Spalten speziell zu formatieren (zum Beispiel als Datum oder Zahl). Überspringt man diesen Schritt, werden die Daten eventuell fehlerhaft importiert, weil Excel ihnen ein falsches Format zuordnet.\n\n\n\nAnschließend klickt man auf „Fertig stellen“ und Excel trennt die Daten aus der ersten Spalte bei jedem Komma in eine neue Spalte ab. Ein mögliches Problem, was dabei auftreten kann, ist dass auch Spalten aufgeteilt werden, die eigentlich zusammen gehören.\n\n\n\nAuffällige Fehler sollten an dieser Stelle bereinigt werden (hier zum Beispiel, indem man „i, daniel blake“ wieder in Spalte A zusammenfügt und anschließend alle weiteren Werte aus der Zeile eine Spalte aufrücken lässt).\nWie in Möglichkeit 2 müssen die Werte außerdem unter dem Reiter „Start“ mit der Funktion „Als Tabelle formatieren“ noch in eine Tabelle umgewandelt werden, um weiter mit ihnen arbeiten zu können.\n\n\n\nIst der Datenbereich korrekt, klickt man in dem daraufhin auftauchenden Fenster auf „OK“.\n\n\n\nHat man beim Importieren der Daten allerdings nicht alle Spalten korrekt formatiert, lässt sich an diesem Punkt dennoch nicht verlässlich mit der Tabelle arbeiten: Hat Excel manchen Spalten von sich aus ein falsches Format zugeordnet (wie hier in Spalte L: aus dem Rating wird ein Datum), muss unter Umständen der gesamte Prozess wiederholt werden, um am Ende die richtigen Werte zu erhalten (da eine Nachkorrektur der Formatierung der Spalte nicht automatisch zum Ursprungswert führt)."
  },
  {
    "objectID": "datensortieren.html#filtern-der-daten-in-excel",
    "href": "datensortieren.html#filtern-der-daten-in-excel",
    "title": "Daten sortieren und filtern mit Excel",
    "section": "Filtern der Daten in Excel",
    "text": "Filtern der Daten in Excel\nWenn man die csv-Datei erfolgreich in Excel geöffnet hat und die Daten in Tabellenform vorliegen, lassen sich diese anschließend einfach durchsuchen, filtern und weiterverarbeiten.\nEs kann zum Beispiel hilfreich sein die Filme im Datensatz nach ihrem Erscheinungsjahr zu sortieren.\n\nDazu klickt man auf das kleine Dreieck neben der Spaltenbeschriftung.\n\n\n\nDaraufhin öffnet sich ein Menüfenster, in dem man zum Beispiel nach einzelnen Jahren Filtern kann, oder sich durch das Klicken auf „Aufsteigend“ alle Titel in der Liste in chronologischer Reihenfolge nach ihrem Erscheinungsjahr anzeigen lassen kann.\n\n\nEntsprechend kann man sich zum Beispiel in der Spalte „Gender“ durch das Menüfenster ausschließlich die Filme männlicher oder weiblicher Regisseure anzeigen lassen:\n\nOder man ordnet die Filmtitel durch die Auswahl „Aufsteigend“ in alphabetischer Reihenfolge:\n\nWenn man wieder alle Daten sehen möchte, wählt man die Filter ab. Gefilterte Spalten sind an der Stelle des kleinen Dreiecks markiert und dadurch leicht zu finden.\nAlle Screenshots wurden von Katharina Kauth erstellt. Zuletzt bearbeitet am 31.10.2023"
  },
  {
    "objectID": "diagrammtypenrawgraphs.html",
    "href": "diagrammtypenrawgraphs.html",
    "title": "Diagrammtypen in RAWGraphs",
    "section": "",
    "text": "Die auf dieser Unterseite versammelten Materialien stellen derzeit noch Work-in-progress dar. Wir bitten daher etwaige Rechtschreibfehler und Inkonsistenzen zu entschuldigen.\nRAWGraphs stellt verschiedene Diagrammtypen zur Verfügung, mit denen Daten visualisiert werden können. Abhängig davon, welchen Aspekt der Daten man in den Vordergrund stellen möchte, kann ausgewählt werden, in welcher Diagrammform die Daten präsentiert werden sollen. Es gibt dabei nicht eine einzige Art und Weise, wie die Daten korrekt dargestellt werden können. Die Wahl eines Diagrammtyps hängt stark von der Darstellungsintention ab. Würde man beispielsweise mit Daten zu Flughäfen in verschiedenen Ländern arbeiten, könnte man zum einen durch ein Balkendiagramm (Bar chart) darstellen, wieviele Flughäfen pro Land vorhanden sind (Häufigkeiten). Möchte man nicht nur eine reine Anzahl darstellen, sondern die Namen der Flughäfen, ihre Lokalisierung in einem Land und die von dort operierenden Fluggesellschaften, würde sich die Darstellung als Hierarchie anbieten, wobei das Land die oberste Hierarchiebene, der Flughafenname die mittlere Hierarchiebene und die Fluggesellschaften die unterste Hierarchieebene darstellen würden. Eine weitere Möglichkeit wäre, die Entwicklung der Anzahl von Flughäfen eines Landes in einem Vergleich über 20 Jahre zu präsentieren (Veränderungen im Zeitverlauf). Inwiefern die Flughäfen miteinander vernetzt sind und von welchem Flughafen welche anderen Flughäfen erreichbar sind, ließe sich wiederum mit einem Netzwerk darstellen.\nDie nachfolgende Beschreibung der jeweiligen Diagrammtypen basiert auf den in RAWGraphs zur Verfügung gestellten Tutorials, der Webseite “How to Choose the Right Data Visualization” sowie den eigenen im DiCi-Hub-Team gemachten Erfahrungen mit Visualisierungen. Es wird im Folgenden nicht jeder in RAWGraphs vorhandene Diagrammtyp vorgestellt, sondern die gängigsten Varianten, die man typischerweise in den Geisteswissenschaften nutzt."
  },
  {
    "objectID": "diagrammtypenrawgraphs.html#hierarchien",
    "href": "diagrammtypenrawgraphs.html#hierarchien",
    "title": "Diagrammtypen in RAWGraphs",
    "section": "Hierarchien",
    "text": "Hierarchien\nDie in RAWGraphs vorhandenen Diagrammtypen für hierarchisch strukturierte Daten sind sich sehr ähnlich, was die Erstellung einer Visualisierung und die vorausgesetzte Grundstruktur der Daten angeht. Der einzige Unterschied zwischen den Diagrammtypen ist die räumliche Anordnung der einzelnen Elemente in der Darstellung.\n\nTreemap\nAlternative Namen: Kacheldiagramm\n\nWas stellt es dar: In einer Treemap können hierarchisch strukturierte Daten dargestellt werden. Die Daten sind nach Kategorien sortiert. Es existieren Oberkategorien, die in verschiedene Unterkategorien unterteilt werden. Die Unterkategorien können ebenfalls Unterkategorien enthalten. Für jede Kategorie wird eine Kachel eingefügt. Oberkategorien bestehen dementsprechend aus einer großen Kachel, in die kleinere Kacheln eingefügt werden. Die größe der Kacheln ist dabei abhängig von der Größe/Häufigkeit der Kategorie. Die Oberkategorien können farblich unterschieden werden.\nBeispiel hier: Dargestellt sind Städte mit den höchsten Einwohnerzahlen sortiert nach Kontinenten. Die Kontinente bilden die jeweilige Oberkategorie, die Städte sind als Kacheln den Kontinenten farblich zugeordnet. Die Größe der Kacheln ist abhängig von der Größe der Bevölkerung der Stadt.\nWelche Fehler sollten allgemein in Bezug auf diesen Diagrammtyp vermieden werden: Theoretisch kann die Anzahl der Hierarchieebenen in den Daten beliebig groß sein. Das heißt Unterkategorien könnten Unterkategorien haben, die wiederum Unterkategorien haben etc. Dies macht das Diagramm jedoch schnell unübersichtlich und unlesbar. Es ist sinnvoll nicht mehr als drei Hierarchieebenen zu haben.\nWas ist bei RAWGraphs zu diesem Diagrammtyp zu beachten: Da es in RAWGraphs keine umfassende Möglichkeit gibt, die Position von Beschriftungen zu verändern, passiert es in RAWGraphs bei diesem Diagrammtyp leicht, dass die Beschriftung der Kacheln abgeschnitten wird. Dieses Problem kann etwas behoben werden, indem die Gesamtgraphik größer gemacht und in die Breite gezogen wird. Dies ist jedoch nur begrenzt machbar ohne das Diagramm zu stark zu verzerren. Außerdem ist es möglich in der Rubrik “4. Customize” unter Chart die Form und Anordnung der Kacheln zu beeinflussen (Tiling Method). Auch der Abstand zwischen den Kacheln kann vergrößert oder verkleinert werden (Padding).\nSo könnte eine geeignete Datentabelle aufgebaut sein: Hierarchische Daten erfordern die Angabe von Kategorien, die jeweils in einer Spalte stehen. Zusätzlich kann eine Spalte vorliegen, die etwas über die Größe einer der Kategorien aussagt.\nNachfolgend ist ein vereinfachter Auszug aus dem in RAWGraphs genutzten Beispieldatensatz Most Populated cities per continent gezeigt:\n\n\n\n\n\n\n\n\n\nOberkategorie / Continent\nUnterkategorie der Oberkategorie / Country\nUnterkategorie der Unterkategorie / City\nGröße der Unterkategorie der Unterkategorie / Population\n\n\n\n\nSouth America\nPeru\nLima\n8894412\n\n\nSouth America\nBrazil\nRio de Janeiro\n6476631\n\n\nAsia\nChina\nShanghai\n24256800\n\n\nAfrica\nNigeria\nLagos\n17578000\n\n\n\nSo wäre eine Datentabelle für eine Treemap in RAWGraphs ungeeignet: Die Daten müssen klaren Kategorien zugeordnet sein, ansonsten ist keine Hierarchisierung möglich.\nWelche Variablen werden in RAWGraphs für diesen Diagrammtyp benötigt:\n\nHierarchy*: ist Pflichtfeld. Hier können beliebig viele Kategorien eingefügt werden. Jedes Datenformat ist hier möglich.\nSize: Bestimmt die Größe der Kacheln. Hier ist im Normfall die unterste Kategorie zu nutzen. Es muss sich dabei um Zahlenwerte handeln.\nColor: Hier kann einen Kategorie ausgewählt werden, die die Farbe der zugehörigen Kacheln bestimmt. Im Normalfall ist hier die Oberkategorie zu nutzen. Jedes Datenformat ist hier möglich.\nLabel: Das Label sorgt für die Beschriftung der Einzelkacheln. Hier ist im Normfall die unterste Kategorie zu nutzen. Jedes Datenformat ist hier möglich.\n\n\nCircle Packing\nAlternative Namen: Circular Treemap\n\nDer Diagrammtyp Circle Packing funktioniert analog zum Diagrammtyp Treemap, siehe daher die Beschreibung dort. Der Unterschied zwischen den beiden Diagrammtypen ist, dass beim Circular Packing anstatt eckiger Kacheln Kreise zur Darstellung genutzt werden. In der Rubrik “4. Customize” unter Chart kann die Anordnung der Kreise im Diagramm verändert werden, indem sie absteigend oder aufsteigend nach ihrer Größe sortiert werden.\n\n\nLinear dendrogram\nAlternative Namen: Clusterbaum, Baumdiagramm\n\nWas die zugrundeliegende Datenstruktur und das Mapping angeht, funktioniert ein Linear dendogram prinzipiell wie eine Treemap, siehe daher die Beschreibung dort. Ein Linear dendogram ist so aufgebaut, dass die Oberkategorie als Punkt auf der linken Seite des Diagramms dargestellt ist, von diesem Oberkategorie-Punkt zweigen die Unterkategorien wie die Äste eine Baumes ab und bilden eigene Punkte aus, von denen weitere Unterkategorien abzweigen können. Die Größe der Punkte zeigt, wie es auch bei den Kacheln einer Treemap der Fall ist, die Größe der Kategorie an. In der Rubrik “4. Customize” unter Chart kann die maximale Größe eines Kreises definiert werden. Unter “Layout Algorithm” kann die Baumstruktur zudem angepasst werden. Die jeweiligen Unterkategorien können abhängig von ihrer Größe aufsteigend oder absteigen oder alphabetisch angeordnet werden (Sort nodes by).\n\n\nCircular dendrogram\nAlternative Namen: Radial Tree\n\nWas die zugrundeliegende Datenstruktur und das Mapping angeht, funktioniert ein Circular dendogram prinzipiell wie eine Treemap, siehe daher die Beschreibung dort. Des Weiteren besteht eine große Ähnlichkeit mit einem Linear dendrogram. Während das Linear dendrogram jedoch die Äste mit den abzweigenden Unterkategorien in eine Richtung erstreckt (im Normalfall von links nach rechts), sind bei einem Circular dendrogram alle abzweigenden Unterkategorien kreisförmig um die Oberkategorie angeordnet. Ansonsten gelten auch hier die für das Linear dendrogram gemachten Erklärungen.\n\n\nSunburst diagram\nAlternative Namen: Ring Chart, Radial Treemap\n\nEin Sunburst diagram funktioniert prinzipiell wie eine Treemap, siehe daher die Beschreibung dort. Anders als in der Treemap mit ihren ineinander geschachtelten Kacheln, ist im Fall eines Sunburst diagrams jede Hierarchiebene durch einen Ring repräsentiert, der sich um die jeweilige übergeordnete Kategorie legt. Dies bedeutet, dass sich die Oberkategorie in der Mitte befindet, während die unterste Kategorieebene außen zu finden ist. Das Diagramm bildet keinen gleichförmigen Kreis, da unterschiedlich viele Unterkategorien zugeordnet sein können. Dies stellt einen Vorteil zu einer Treemap oder anderen hierarchischen Diagrammtypen dar, da in einem Sunburst Diagram mehr Unterkategorien dargestellt werden können, ohne das Diagramm sofort unlesbar zu machen. Aber auch hier sollte die Anzahl an Unterkategorien begrenzt werden, um nicht an Übersichtlichkeit einzubüßen."
  },
  {
    "objectID": "diagrammtypenrawgraphs.html#häufigkeiten",
    "href": "diagrammtypenrawgraphs.html#häufigkeiten",
    "title": "Diagrammtypen in RAWGraphs",
    "section": "Häufigkeiten",
    "text": "Häufigkeiten\n\nBar chart\nAlternative Namen: Balkendiagramm, Säulendiagramm\n\nWas stellt es dar: Ein Bar chart ist ein Diagramm mit zwei Achsen, in dem mehrere „Balken“ nebeneinander angeordnet sind. Eine Achse stellt dabei eine kategorische Einteilung dar, die andere den Wert der jeweiligen Kategorie.\nBeispiel hier: Die Beliebtheit (Durchschnitt des IMDB-Ratings) von verschiedenen Serien-Genres im Zeitraum von 2013-2017. Auf der Y-Achse des Bar chart findet sich die Kategorisierung (die einzelnen Genres) und auf der X-Achse die jeweiligen Werte (das durchschnittliche IMDB-Rating). Diese Visualisierung wird jeweils für die Jahre 2013-2017 (also als eine Serie) wiederholt.\nWelche Fehler sollten allgemein in Bezug auf diesen Diagrammtyp vermieden werden: Mit einem Bar chart kann eine Verteilung von Datenpunkten oder auch ein Vergleich von Werten realisiert werden. Dafür sind einerseits eindeutige Kategorien (Genre, Länder, Jahre, etc.) notwendig, andererseits numerische Werte (Rating, Einwohnerzahl, Verkaufszahlen, etc.) Ein Bar Chart kann auf verschiedene Weise verfälscht werden:\n\nDie Werte-Achse sollte bei 0 beginnen und keine Lücken aufweisen.\nEs sollten keine Abrundungen oder 3d Effekte verwendet werden (diese schränken die Vergleichbarkeit der einzelnen Balken ein).\nEs sollten keine unnötigen Einfärbungen verwendet werden (dadurch könnten ungewollte, zusätzliche Bedeutungen wahrgenommen werden).\nKategorien sollten nach der Größe ihrer Werte sortiert werden (dies macht einen Vergleich einfacher).\nEs sollten keine Bilder oder Icons als Balken verwendet werden (dies verzerrt oft Aussage der Graphik).\n\nWas ist bei RAWGraphs zu diesem Diagrammtyp zu beachten: Es ist wichtig, dass die Spalte des Datensatzes mit den numerischen Werten auch tatsächlich nur Zahlen enthält.\nNutzt man beim Mapping in RAWGraphs nur das Pflichtfeld “Bars” werden die einzelnen Balken nicht mit ihren zugehörigen Werten dargestellt, sondern die Balkengröße wird durch die Häufigkeit der Kategorie/des Balkennamens wiedergegeben, was in vielen Fällen einfach nur 1 sein wird. In der Rubrik “4. Customize” unter Chart kann eingestellt werden, ob die Balken des Diagramms horizontal oder vertikal angeordnet werden sollen (Bars orientation). Die Balken können ab- und aufsteigend nach Größe oder alphabetisch angeordnet werden (Sort bars by). Auch der Abstand zwischen den Balken kann verändert werde (Padding).\nSo könnte eine geeignete Datentabelle aufgebaut sein: Nachfolgend ist ein vereinfachter Auszug aus dem in RAWGraphs benutzten Beispieldatensatz Netflix Original Series 2013/2017 gezeigt:\n\n\n\n\n\n\n\n\n\nMindestens eine Art von Kategorie (beispielsweise Genre)\nEine weitere beliebige Art von Kategorie (beispielsweise Titel)\nMindestens eine Art von numerischen Werten (beispielsweise Rating)\nBeliebig viele weitere Spalten mit Kategorien oder Werten\n\n\n\n\nAnimation\nStar Wars: The Clone Wars (season 6)\n80\n…\n\n\nComedy\nArrested Development (season 4)\n89\n…\n\n\n\nSo wäre eine Datentabelle für einen Bar chart in RAWGraphs ungeeignet:\n\n\n\nGenre\nTitle\nSubgenre\n\n\n\n\nComedy\nBoJack Horseman\nAdult Animation\n\n\nComedy\nTrailer Park Boys (seasons 8, 9, 10 and 11)\nMockumentary\n\n\n\nHier fehlt eine Spalte mit numerischen Werten für die einzelnen Kategorien. Sobald jedoch mindestens eine Spalte mit Kategorien und mindestens eine Spalte mit numerischen Werten vorhanden ist, kann ein Bar Chart erstellt werden – es ist deshalb auch wesentlich einfacher zu erstellen als andere, komplexere Visualisierungen.\nWelche Variablen werden in RAWGraphs für diesen Diagrammtyp benötigt:\n\nBars*: ist Pflichtfeld. Hier werden die Kategorien eingefügt, die die jeweiligen Balken bilden. Es kann jedes Datenformat hier genutzt werden.\nSize: Hier wird der Wert eingefügt, der die Höhe des jeweiligen Balkens bestimmt. Es muss sich dabei um ein Zahlenformat handeln.\nColor: Die Balken können farbig markiert werden. Dies kann dann Sinn machen, wenn mehrere Balken einer gemeinsamen Oberkategorie vorliegen und die Einfärbung gemäß dieser Oberkategorie geschieht. Jedem einzelnen Balken eine unterschiedliche Farbe zu geben, führt nicht unbedingt zu einer besseren Übersichtlichkeit. Hier kann jedes Datenformat genutzt werden.\nSeries: erlaubt eine Serie von Balkendiagrammen zu erstellen, wenn z.B. Daten für verschiedene Jahre oder beispielsweise für verschienden Länder vorliegen. Hier kann jedes Datenformat genutzt werden.\n\n\nMulti-set bar chart\nAlternative Namen: Grouped Bar Chart, Gruppiertes Balken-/Säulendiagramm\n\nWas stellt es dar: Ein Multi-set bar chart erfüllt eine ähnliche Funktion wie ein Stacked bar chart: Es können zwei kategorische Dimensionen dargestellt werden. Die primären Kategorien werden auf der X-Achse angeordnet. Zu jeder dieser primären Kategorien existiert aber gleichzeitig ein jeweils identisches Set von Unterkategorien, die als farblich unterschiedene Balken jeder der primären Kategorien zugeordnet werden. Ein Multi-set bar chart ist nützlich, um die Veränderung von Unterkategorien im Kontext einer primären Kategorisierung zu untersuchen. Dabei können Vergleiche innerhalb einer Gruppe angestellt werden, indem die Werte der einzelnen Unterkategorien in einer primären Kategorie verglichen werden oder Vergleiche außerhalb einer Gruppe angestellt werden. Gleichzeitig können aber auch Werte der einzelnen Unterkategorien zwischen mehreren primären Kategorien verglichen werden.\nBeispiel hier: Die Länder mit den zehn größten Bruttoinlandsprodukten werden dargestellt. Jedes Land (primäre Kategorisierung) erhält eine Gruppe von Balken, welche die einzelnen Sektoren des Bruttoinlandsprodukt (sekundäre Kategorisierung) darstellen.\nWelche Fehler sollten allgemein in Bezug auf diesen Diagrammtyp vermieden werden: Wichtig ist, welche Kategorie die primäre Dimension (X-Achse) ist und welche die sekundäre Dimension (die einzelnen Balken) darstellt. Zeitliche Daten (Jahreszahlen), numerische Hierarchien (Altersgruppen) sind meistens primär. Typen (Gender, Länder) sind meistens sekundär. Letztendlich ist dies aber je nach Visualisierung anders möglich. Der Multi-set bar chart ist nicht geeignet, um die Gesamtverteilung der primären Kategorien zu vergleichen. In diesem Fall ist ein Bar chart, ein Stacked bar chart oder ein Pie chart sinnvoller. Gleichzeitig ist zu bedenken, dass in einem Multi-set bar chart nur eine bestimmte Anzahl von Balken darstellbar ist, um eine Übersichtlichkeit zu gewährleisten. Die Anzahl der primären Kategorien muss daher, auch in Abhängigkeit von der Anzahl der Unterkategorien, begrenzt werden.\nWas ist bei RAWGraphs zu diesem Diagrammtyp zu beachten: In der Rubrik “4. Customize” unter Chart besteht die Möglichkeit den Abstand zwischen den Gruppen und den einzelnen Balken einzustellen. Des Weiteren können die primären Kategorien auf der X-Achse ab- und aufsteigend nach ihren Werten oder alphabetisch nach ihren Namen sortiert werden (Sort X axis by).\nSo könnte eine geeignete Datentabelle aufgebaut sein: Nachfolgend ist ein vereinfachter Auszug aus dem in RAWGraphs benutzten Beispieldatensatz GDP sector composition dargestellt.\nEs müssen mindestens zwei Spalten mit Arten von numerischen Werten vorliegen, die die sekundären Kategorien des Multi-set bar chart bilden.\n\n\n\n\n\n\n\n\nEine Art von Kategorie (beispielsweise Land)\nEine Art von numerischen Werten (beispielsweise Umsatz in Landwirtschaft)\nEine weitere Art von numerischen Werten (beispielsweise Umsatz in Industrie)\n\n\n\n\nChina\n1833590\n9400050\n\n\nEuropean Union\n333600\n5233350\n\n\n\nSo wäre eine Datentabelle für einen Multi-set bar chart in RAWGraphs ungeeignet: Es muss mindestens eine Art von primärer Kategorie und mindestens zwei Arten von numerischen Werten vorliegen, die die sekundären Kategorien bilden.\nWelche Variablen werden in RAWGraphs für diesen Diagrammtyp benötigt:\n\nX Axis*: ist Pflichtfeld. Hier werden die primären Kategorien angegeben, die auf der X-Achse angezeigt werden. Jedes Datenformat ist hier möglich.\nSize: Hier werden die sekundären Kategorien eingefügt, deren Werte die einzelnen Balken darstellen. Die Werte müssen im Zahlenformat vorliegen.\nSeries: erlaubt eine Serie von Balkendiagrammen zu erstellen, wenn z.B. Daten für verschiedene Jahre oder beispielsweise für verschienden Länder vorliegen. Hier kann jedes Datenformat genutzt werden.\n\n\nStacked bar chart\nAlternative Namen: gestapeltes Balken-/Säulendiagramm\n\nWas stellt es dar: Ein Stacked bar chart weist viele Parallelen zur einem Bar chart und einem Multi-set bar chart auf. Gegenüber einem einfachen Bar chart kann, genau wie bei einem Multi-set bar chart, in einem Stacked bar chart eine weitere kategorische Dimension in der Visualisierung berücksichtigt werden. Jeder Balken einer primären Kategorie ist in mehrere Abschnitte aufgeteilt, wobei diese jeweils die Werte einer zusätzlichen, sekundären Kategorie anzeigen (siehe dazu auch die Beschreibung zum Multi-set bar chart).\nBeispiel hier: Die zehn Länder mit dem größten Bruttoinlandsprodukt und dessen Zusammensetzung. Auf der X-Achse findet sich die erste Kategorie-Dimension (Länder), auf der Y-Achse die jeweiligen Werte (die Größe des Bruttoinlandsprodukt). Die Unterteilung der Balken stellt die zweite Kategorie-Dimension dar (Sektoren des Bruttoinlandsprodukt).\nWelche Fehler sollten allgemein in Bezug auf diesen Diagrammtyp vermieden werden: Eine große Herausforderung für die Lesbarkeit des Diagramms stellt dar, dass nur der Balken ganz links neben der Beschriftung der X-Achse steht. Je weiter rechts ein Balken steht, desto schwerer wird es, genaue Werte abzulesen. Daher sollte auf zu viele Balken verzichtet werden. Für weitere Anmerkungen siehe auch die Beschreibung zum Multi-set bar chart.\nWas ist bei RAWGraphs zu diesem Diagrammtyp zu beachten: In der Rubrik “4. Customize” unter Chart kann zum einen der Abstand der Balken zueinander verändert werden (Padding). Zum anderen können die primären Kategorien auf der X-Achse ab- und aufsteigend nach ihren Werten oder alphabetisch nach ihren Namen sortiert werden (Sort X axis by). Des Weiteren kann die Reihenfolge der aufeinander gestapelten Balkenelemente ab- und aufsteigend nach Größe anpasst werden (Sort stacks by).\nSowohl in Bezug auf den notwendigen Aufbau der Datentabelle als auch das Mapping siehe die Angaben zum Multi-set bar chart."
  },
  {
    "objectID": "diagrammtypenrawgraphs.html#verteilungen",
    "href": "diagrammtypenrawgraphs.html#verteilungen",
    "title": "Diagrammtypen in RAWGraphs",
    "section": "Verteilungen",
    "text": "Verteilungen\n\nBox plot\nAlternative Namen: Box-Whisker-Plot, Kastendiagramm\n\nWas stellt es dar: Der Diagrammtyp zeigt, in welchem Bereich die Daten liegen und wie sie sich über diesen Bereich verteilen. Es lässt sich dadurch erkennen, ob die Werte gleichmäßig verteilt sind oder eine „schiefe“ Verteilung vorliegt, wobei die Werte vermehrt in einem Bereich liegen. Ein Box plot ist dann von Vorteil, wenn man verschiedene Werte miteinander vergleichen will, also mehrere „Kästen“ (Boxes) nebeinander stellen kann, wie im oben gezeigten Beispiel. Ein Box plot ist dabei aus unterschiedlichen Werten zusammengesetzt:\nWerte innerhalb des „Kastens“\n- der „Kasten“ an sich umfasst 50% der vorhandenen Daten\n- unterste Begrenzung des Kastens = Unteres Quartil: 25% der Datenwerte sind gleich oder kleiner als dieser Wert\n- Strich innerhalb des Kastens = Median: 50% der Datenwerte sind gleich oder kleiner als dieser Kennwert\n- oberste Begrenzung des Kastens = Oberes Quartil: 75% der Datenwerte sind gleich oder kleiner als dieser Kennwert\ndie beiden „Antennen“ (=Whisker)\n- oberstes Ende des oberen Whiskers = der maximalste Datenwert\n- unterstes Ende des unteren Whiskers = der minimalste Datenwert\nBeispiel hier: Wetter in New York 2012-2015. Hier werden die Höchsttemperaturen in New York in Zusammenhang mit der Wetterlage gesetzt (wie sind die Höchsttemperaturen während Sonnenschein, Regen, Nieselregen, Schnee oder Nebel). Betrachtet man die Höchsttemperaturen bei Regen, sieht man, dass sich die Temperaturwerte zwischen 2.8 und 37.2 Grad bewegen. Wie der „grüne Kasten“ zeigt, liegen 25% der gemessenen Werte unterhalb von 12.8 Grad und 75% der gemessenen Werte liegen unter 25.5 Grad. 50% der Datenwerte sind niedriger bzw. höher als 18.9 Grad.\nWelche Fehler sollten allgemein in Bezug auf diesen Diagrammtyp vermieden werden: Was ein Box plot nicht zeigen kann, ist die exakte Häufigkeit, mit der ein Einzelwert auftritt. In dem oben genannten Beispiel können wir z.B. nicht ablesen, ob die niedrigste Temperatur von 2.8 Grad nur einmalig auftritt oder vielleicht sogar zweimal gemessen wurde. Um darzustellen, wie oft ein einzelner Temperaturwert gemessen wurde, muss auf einen anderen Diagrammtyp wie z.B. ein Histogramm zurückgegriffen werden. Histogramme als Diagrammtyp sind allerdings in RAWGraphs nicht verfügbar und müssten mit einem anderen Tool erstellt werden. Eine Alternative stellen noch Violin plots dar.\nWas ist bei RAWGraphs zu diesem Diagrammtyp zu beachten: Mit anderen Tools lassen sich auch leicht abgewandelte Box plots erstellen, die etwas anders mit Maximal- und Minimalwerten umgehen. Mit RAWGraphs kann allerdings nur die oben dargestellte Form eines Box plots erstellt werden. Ein paar Erklärungen hierzu findet man auch in einem Wikipedia-Artikel zu Box plots.\nIn der Rubrik “4. Customize” unter Chart lässt sich zum einen die Breite der einzelnen “Kästen” (Bars width), zum anderen der Durchmesser von Punkten (Dots diameter) verändern, die als Ausreißer-Daten in dem Diagrammtyp dargestellt werden können (im oben gezeigten Diagramm ist dies nicht der Fall, da die Datenbasis dies nicht hergibt). Unter Ausreißer-Daten versteht man Datenwerte, die deutlich höher oder niedriger als der Großteil der Werte insgesamt sind. Inwieweit man diese Ausreißer-Daten tatsächlich als Ausreißer verstehen möchte, lässt sich mit der Option “Interquartile range multiplier” regeln. Je höher der Wert hier ist, desto weniger werden Datenwerte als Ausreißer verstanden.\nIn dem Fall, wo alle Datenwerte der Y-Achse deutlich höher als null liegen, beginnt RAWGraphs automatisiert die Skala der Achse nicht bei null, sondern bei einem anderen, höheren Wert. Möchte man trotzdem die Achse bei null beginnen lassen, kann dies durch die Option “Set Y origin to 0” eingestellt werden.\nSo könnte eine geeignete Datentabelle aufgebaut sein: Folgendes ist ein vereinfachter Auszug zu dem in RAWGraphs benutzten Datensatz zu Weather in New York, 2012-2015:\n\n\n\n\n\n\n\nEinzelne Werte/Höchsttemperaturen\nBezeichnung der einzelnen Gruppen, nach denen die jeweiligen „Kästen“ erstellt werden; dieser Part ist optional; enthält die Tabelle nur Werte zu einem einzelnen Objekt, kann auch nur ein einzelner “Kasten” erstellt werden; da die Verteilung von Werten jedoch oft erst im Vergleich interessant ist, bietet es sich an, verschiedene “Kästen” gegenüber zu stellen/Wetterlage\n\n\n\n\n13.3\nrain\n\n\n-2.2\nsun\n\n\n15.6\nfog\n\n\n5\nsnow\n\n\n30\ndrizzle\n\n\n4.4\nsnow\n\n\n17.8\nfog\n\n\n29.4\ndrizzle\n\n\n9.4\nrain\n\n\n16.1\nsun\n\n\n\nSo wäre eine Datentabelle für einen Box plot in RAWGraphs ungeeignet: Die Einzelwerte müssen untereinander in einer Spalte der Tabelle stehen. Sie dürfen nicht in einer Tabellenzeile stehen.\nWelche Variablen werden in RAWGraphs für diesen Diagrammtyp benötigt:\n\nY-Achse*: ist Pflichtfeld. Hier werden die Angaben zu den einzelnen Werten gemacht, dabei muss es sich immer um Zahlenwerte handeln.\nGroups und Color: sind optionale Variablen, wenn man verschiedene Objekte vergleichen möchte. Die Farbe muss sinnvollerweise den Gruppen entsprechen. Gruppen und davon abhängig die Farben können Zahlenwerte, Datumsangaben oder Wörter sein.\n\n\nViolin plot\nAlternative Namen: Violindiagramm, Geigendiagramm\n\nWas stellt es dar: Ein Violin plot zeigt ähnlich wie ein Box plot, in welchem Bereich die Daten liegen und wie sie sich über diesen Bereich verteilen. In einem Violin plot wird gleichzeitig dargestellt, wie häufig ein einzelner Wert auftritt, was durch die Breite der „Violine“ auf Höhe des jeweiligen Datenwertes dargestellt wird.\nBeispiel hier: Wetter in New York 2012-2015. Hier werden die Höchsttemperaturen in New York in Zusammenhang mit der Wetterlage gesetzt (wie sind die Höchsttemperaturen während Sonnenschein, Regen, Nieselregen, Schnee oder Nebel).\nDa viele Ähnlichkeiten zwischen Box plots und Violin plots vorliegen, gelten die für Box plots beschriebenen Erläuterungen zur Datenstruktur und der Nutzung von Variablen ebenso hier.\nWas ist bei RAWGraphs zu beachten: Es gibt verschiedene Tools, die in der Lage sind, Box plots und Violin plots miteinander zu kombinieren. Dies ist in RAWGraphs aber nicht der Fall. In einem Violin plot können daher die für Box plots so relevanten Werte wie Median, oberstes und unterstes Quartil etc. nicht dargestellt werden. Da in RAWGraphs keine Histogramme erstellt werden können, kommt einem Violin plot die Darstellung einer Dichteverteilung der Werte am nächsten. Allerdings ist aus einem Violin plot in RAWGraphs die exakte Anzahl der Häufigkeit eines Wertes nicht ablesbar, da dies nicht auf der x-Achse dargestellt wird. Der Violin plot gibt eher einen groben Eindruck über die Häufigkeitsverteilung der Werte im Vergleich mit anderen Einzelwerten. Eine ähnliche Möglichkeit der Darstellung ist auch ein Beeswarm plot.\nIn der Rubrik “4. Customize” unter Chart lassen sich verschiedene Einstellungen für einen Violin plot vornehmen. Um einen ungefähren Eindruck von der Häufigkeit der einzelnen Werte zu erhalten, kann für jeden Datenwert ein Punkt in den Violin plot eingefügt werden (Show dots on data values) sowie der Durchmesser dieser Punkte bestimmt werden (Dots diameter). Die Reihenfolge der angezeigten “Violinen” kann anhand der Werte ab- oder aufsteigend oder alphabetisch dargestellt werden (Sort violins by). Des Weiteren kann der Abstand zwischen den einzelnen “Violinen” reguliert werden (Padding) sowie die Form der Violin plots nach verschiedenen mathematischen Berechnungen angepasst werden (Curve type). Die Datenpunkte in einem Violin plot sind gleichmäßig auf verschiedene sogenannte “Bins” verteilt. In RAWGraphs besteht die Möglichkeit die Anzahl der Bins zu variieren (Number of bins), was die Darstellung verändert.\n\n\nBeeswarm plot\nAlternative Namen: Dot Plot, Swarm Plot, Punktdiagramm\n\nWas stellt es dar: Ähnlich einem Violin plot wird die Verteilung von Werten zu verschiedenen Objekten/Sachverhalten im Vergleich dargestellt. Parallel zur x-Achse, auf der eine Reihe von ansteigenden oder abfallenden Wertegrößen angezeigt sind, werden Einzelwerte zu einem Thema entlang einer horizontalen Linie gemäß ihrer Größe ausgerichtet. Liegen mehrere identische Werte vor, werden sie rechts oder links der horizontalen Linie gestapelt angeordnet, um Überlappungen zu vermeiden, wodurch eine Ähnlichkeit mit einem Violin plot entstehen kann. Die Größe der einzelnen Punkte kann durch die Größe des entsprechenden Einzelwertes bestimmt werden.\nBeispiel hier: Durchschnittliches Gehalt in New York abhängig vom Beruf, wobei die einzelnen Berufe Oberkategorien wie Management, Gesundheitswesen etc. zugeordnet werden. In der dargestellten Graphik ist die Größe der Punkte abhängig von der Größe des Gehalts. Daher werden die Punkte immer größer, je weiter rechts man entlang der X-Achse wandert. Die Y-Achse zeigt die Oberkategorien der Berufe. Jeder Punkt stellt einen spezifischen Beruf dar, dessen Label theoretisch ebenfalls in diesem Diagramm dargestellt werden könnte, jedoch aufgrund von Platzgründen weggelassen wurde. Das Diagramm gibt einerseits einen Überblick darüber, wie viele Berufe einer Oberkategorie zugeordnet sind, und andererseits, in welcher Größenordnung sich die Gehälter in dieser Berufsgruppe bewegen. Beispielsweise sieht man, dass sich die Gehälter im Management-Bereich und bei den Practitioners und Technicians in einem hohen Bereich bewegen, während die Gehälter im Office and Administrative Support und auch in Construction and Extraction eher im niedrigeren Bereich gebündelt sind.\nWelche Fehler sollten allgemein in Bezug auf diesen Diagrammtyp vermieden werden: Wenn zu viele einzelne Datenpunkte vorliegen, kann ein Beeswarm plot schnell unübersichtlich werden, da die einzelnen Punkte ineinander verschwimmen und nicht mehr erkennbar sind.\nWas ist bei RAWGraphs zu diesem Diagrammtyp zu beachten: RAWGraphs ist für diesen Diagrammtyp ein sehr gutes Tool. Diese Art von Diagramm ist beispielsweise mit Libraries von Programmiersprachen wie Python deutlich schwerer zu erstellen.\nIn der Rubrik “4. Customize” unter Chart kann die Minimal- und Maximalgröße der Punkte sowie der Abstand zwischen den Punkten (Padding) eingestellt werden.\nSo könnte eine geeignete Datentabelle aufgebaut sein: Nachfolgend ist ein vereinfachter Auszug aus dem in RAWGraphs benutzten Beispieldatensatz New York mean wage per occupation für diesen Diagrammtyp gezeigt.\nEine geeignete Datentabelle für diesen Diagrammtyp enthält eine Spalte, in der die Einzelwerte gelistet sind. Diese Einzelwerte müssen jeweils mit einem Label versehen werden, das sie einer Gruppe zuordnet (in diesem Fall der Oberkategorie). Werden keine Gruppen angegeben, würden automatisch alle Werte einer einzigen Gruppen zugeordnet werden, so dass sich alle Datenpunkte entlang einer einzigen horizontalen Linie anordnen würden. Optional und zusätzlich zu der Gruppierung können den Einzelwerten auch spezifische Labels zugeordnet werden (in diesem Fall die Bezeichnungen für die einzelnen Datenpunkte).\n\n\n\n\n\n\n\n\nName eines einzelnen Datenpunktes/Occupation\nEinzelwerte/Mean Wage\nOberkategorie, der ein einzelner Datenpunkt zugeordnet wird/Category\n\n\n\n\nChief Executives\n219390\nManagement\n\n\nFuneral Home Managers\n111230\nManagement\n\n\nHuman Resources Specialists\n77550\nBusiness and Financial Operations\n\n\nLogisticians\n77340\nBusiness and Financial Operations\n\n\nGenetic Counselors\n94930\nHealthcare Support\n\n\nPhysical Therapist Assistants\n56620\nHealthcare Support\n\n\n\nSo wäre eine Datentabelle für einen Beeswarm plot in RAWGraphs ungeeignet: Ähnlich wie bei einem Box plot und Violin plot müssen die Einzelwerte in einer Spalte untereinander gelistet werden und dürfen nicht als Tabellenzeile strukturiert sein. Die Werte müssen Gruppen zugeordnet werden. Liegen lediglich Einzelbezeichnungen für Datenpunkte ohne Gruppierung vor, ist es nicht möglich einen Beeswarm plot darzustellen.\nWelche Variablen werden in RAWGraphs für diesen Diagrammtyp benötigt:\n\nX Axis*: ist Pflichtfeld. Einfügen der Spalte mit den Einzelwerten. Dabei muss es sich immer um eine Zahl oder ein Datum handeln\nSize: Hier wird die Größe der Datenpunkte bestimmt. Dies basiert meist auf der Höhe der Einzelwerte, so dass diese Variable identisch mit der Variable der X-Achse ist.\nColor: Die Farbgebung orientiert sich nach der Gruppe (s.u. Groups), der die jeweiligen Einzelwerte zugeordnet werden.\nLabel: Hier können die Namen der Einzelbezeichnungen der Datenwerte eingetragen werden. In diesem Fall wären es die Berufsbezeichnungen. Bei vielen Datenpunkten kann dies allerdings schnell unübersichtlich werden.\nGroups: Hier werden die Gruppen eingefügt, denen die Einzelwerte jeweils zugeordnet werden, in diesem Fall sind es Oberkategorien für die Berufsbezeichnungen."
  },
  {
    "objectID": "diagrammtypenrawgraphs.html#veränderungen-im-zeitverlauf",
    "href": "diagrammtypenrawgraphs.html#veränderungen-im-zeitverlauf",
    "title": "Diagrammtypen in RAWGraphs",
    "section": "Veränderungen im Zeitverlauf",
    "text": "Veränderungen im Zeitverlauf\n\nLine chart\nAlternative Namen: Liniendiagramm\n\nWas stellt es dar: In einem Diagramm mit zwei Achsen, bei dem die X-Achse einen Verlauf (meistens von Zeit) und die Y-Achse eine Skala von Werten anzeigt, werden einzelne Datenpunkte mit Linien verknüpft. So können (meist zeitliche) Veränderungen dieser Werte visualisiert werden. Ein Line chart dient dazu, Veränderungen von Werten im Kontext von kontinuierlichen anderen Werten zu zeigen.\nBeispiel hier: Die Gewinnmargen der Musikindustrie durch verschiedenen Medien in den Jahren 1970 bis 2000. Auf der X-Achse findet sich der zeitliche Verlauf in Jahren, auf der Y-Achse die Skala der Verkaufszahlen. Die einzelnen Datenpunkte der unterschiedlichen Medien sind durch Linien verbunden und zur Differenzierung eingefärbt.\nWelche Fehler sollten allgemein in Bezug auf diesen Diagrammtyp vermieden werden: Es sollten nicht zu viele Linien gleichzeitig visualisiert werden (fünf sind meistens sinnvoll), da die Visualisierung sonst schnell unübersichtlich wird. Alternativ kann eine Serie mit mehreren Diagrammen hier Abhilfe schaffen.\nWas ist bei RAWGraphs zu diesem Diagrammtyp zu beachten: In der Rubrik “4. Customize” unter Chart besteht die Möglichkeit, die einzelnen Datenwerte als Punkte darzustellen, die durch eine Linie verbunden werden oder eine Linie ohne einzelne Datenwertpunkte darzustellen (Show dots on data values). Der Durchmesser dieser Punkte kann ebenfalls definiert werden (Dots diameter). Die Form der Kurve kann nach verschiedenen mathematischen Berechnungen angepasst werden (Curve type).\nIn dem Fall, wo alle Datenwerte der Y-Achse deutlich höher als null liegen, beginnt RAWGraphs automatisiert die Skala der Achse nicht bei null, sondern bei einem anderen, höheren Wert. Möchte man trotzdem die Achse bei null beginnen lassen, kann dies durch die Option “Set Y origin to 0” eingestellt werden.\nUnter “4. Customize” ist im Gegensatz zu anderen Diagrammtypen auch der Abschnitt Axes verfügbar, wo die Möglichkeit besteht, die Beschriftung der X-Achse zu verändern. Es können nicht nur Angaben zu jedem einzelnen Datenwert gemacht werden, sondern auch nur die Minimal- und Maximalwerte gezeigt werden oder eine ausgewählte Anzahl von Werten.\nSo könnte eine geeignete Datentabelle aufgebaut sein: Folgendes ist ein vereinfachter Auszug zu dem in RAWGraphs benutzten Datensatz zu Revenues per Music format:\n\n\n\n\n\n\n\n\nEine kontinuierliche Werteskala/Year\nEinzelne Datenpunkte/Revenue\nGgf. unterschiedliche Kategorien, falls mehrere Linien gezeichnet werden sollen/Format\n\n\n\n\n2019\n6.795945687\nVinyl\n\n\n2018\n5.290337079\nVinyl\n\n\n2018\n8.605769716\nDownload\n\n\n\nSo wäre eine Datentabelle für einen Line chart in RAWGraphs ungeeignet: Die Datentabelle darf keine Datenlücken entlang der Zeitachse aufweisen, da ansonsten der Linienverlauf nicht korrekt dargestellt wird. Es wird dann keine Lücke in der Linie erzeugt, sondern der fehlende Wert als null gerechnet. Von der Darstellung her entsteht somit der Eindruck einer abfallenden und wieder ansteigenden Kurve, obwohl der Wert letztlich einfach fehlt.\nWelche Variablen werden in RAWGraphs für diesen Diagrammtyp benötigt:\n\nX-Axis*: Hier wird der zeitliche Verlauf abgebildet. Meistens handelt es sich dabei um ein Datumsformat, es kann aber auch das Zahlenformat gewählt werden, falls die Zeitangabe nicht als Datum formatiert sein sollte.\nY-Axis*: Hier können die Zahlenwerte oder auch Datumsangaben eingetragen werden, die den jeweiligen Angaben auf der X-Achse zugeordnet sind.\nLines: Lassen sich die Werte der Y-Achse in verschiedene Kategorien einordnen, können diese als unterschiedliche Linien visualisiert werden. Jedes Datenformat ist hier möglich.\nColor: bezieht sich direkt auf die Variable “Lines” und ermöglicht ein Einfärben der verschienden Kategorien. Jedes Datenformat ist hier möglich.\nSeries: kann dann benutzt werden, wenn mehrere Line charts nebeneinander erstellt werden müssen. Dies würde beispielsweise für verschiedene Länder oder auch andere Parameter gelten (diese Parameter können in jedem Datenformat vorliegen).\n\n\nBumpchart\nAlternative Namen: Ranking plot\n\nWas stellt es dar: Es ist eine spezielle Form eines Line chart. Dabei geht es vor allem darum, sichtbar zu machen, wie sich der Rang verschiedener Objekte im Laufe einer Zeitspanne verändert. Für jedes Objekt wird eine breite Linie (= „Stream“) angelegt. Eine farbliche Unterscheidung der einzelnen Streams ist möglich. Nicht sichtbar hierin werden die konkreten Zahlen, die den Rang eines Objekts bestimmen.\nBeispiel hier: Die Entwicklung der Zahl von Einwohner*innen in Mailand, die ursprünglich nicht aus Italien kommen, zwischen 1979-2015. Sichtbar ist, dass die Anzahl an Menschen, die von den Philippinen kommen, sich im Vergleich zu anderen Ländern in den 1980er Jahren im mittleren Bereich bewegt, dann aber ab Ende der 1980er Jahre kontinuierlich ansteigt und schließlich sogar den zweiten Rang einnimmt.\nWelche Fehler sollten allgemein in Bezug auf diesen Diagrammtyp vermieden werden: Zu viele Streams machen das Diagramm unübersichtlich, es sollte nur eine überschaubare Anzahl an Vergleichsobjekten herangezogen werden.\nWas ist bei RAWGraphs zu diesem Diagrammtyp zu beachten: Um das Diagramm übersichtlicher zu machen, kann es hilfreich sein, den Abstand zwischen den einzelnen Streams zu vergrößern. Dies ist in der Rubrik „4. Customize“ unter Charts möglich, indem das Padding erhöht wird. Ebenfalls kann es hilfreich sein, die Kontur/Form der Streams zu verändern (unter Curves Type).\nBumpcharts finden sich in verschiedenen Layouts. Oft handelt es sich dabei einfach um schmale Linien. Das Layout in RAWGraphs ist nicht unbedingt das „klassische“ Layout für einen Bumpchart.\nSo könnte eine geeignete Datentabelle aufgebaut sein: Folgendes ist ein vereinfachter Auszug zu dem in RAWGraphs benutzten Datensatz zu Foreign residents in Milan:\n\n\n\n\n\n\n\n\nName des “Streams”/Country\nZeitangaben für die Zeitachse/Date\nGröße des Streams/Residents\n\n\n\n\nAlbania\n01/01/1979\n34\n\n\nAlbania\n01/01/1980\n30\n\n\nAlbania\n01/01/1981\n28\n\n\nChina\n01/01/1979\n166\n\n\nChina\n01/01/1980\n152\n\n\nChina\n01/01/1981\n194\n\n\nChile\n01/01/1979\n99\n\n\nChile\n01/01/1981\n102\n\n\n\nSo wäre eine Datentabelle für einen Bumpchart in RAWGraphs ungeeignet: Die Datentabelle darf keine Datenlücken entlang der Zeitachse aufweisen, da ansonsten die Streams nicht korrekt dargestellt werden. Es wird dann keine Lücke in den Streams erzeugt, sondern der fehlende Wert als null gerechnet. Von der Darstellung her entsteht somit der Eindruck einer abfallenden und wieder ansteigenden Kurve, obwohl der Wert letztlich einfach fehlt.\nIm Mapping (s.u.) ist nur die Angabe der X-Achse, somit des Zeitverlaufs, verpflichtend. Um einen sinnvollen Bumpchart erstellen zu können, ist aber auch die Angabe der Streams und die Größe der Streams notwendig.\nWelche Variablen werden in RAWGraphs für diesen Diagrammtyp benötigt:\n\nX-Axis*: ist Pflichtfeld. Hier wird der zeitliche Verlauf abgebildet. Meistens handelt es sich dabei um ein Datumsformat, es kann aber auch das Zahlenformat gewählt werden, falls die Zeitangabe nicht als Datum formatiert sein sollte.\nSize: Bestimmt die Größe der einzelnen Streams und muss daher im Zahlenformat vorliegen.\nRanking: (Bedeutung unklar)\nStreams: Hier kann die Spalte eingefügt werden, die die Namen der einzelnen Vergleichsobjekte und damit der einzelnen Streams enthält. Diese werden farblich unterschieden. Jedes Datenformat ist möglich.\nSeries: Hier kann die Spalte eingefügt werden, die die Namen der einzelnen Vergleichsobjekte und damit der einzelnen Streams enthält. Es ist möglich, jedes einzelne Vergleichsobjekt und damit jeden einzelnen Stream in einem separaten Diagramm darzustellen. Die Diagramme werden nebeinander angeordnet, jedoch geht damit die Möglichkeit eines direkten Vergleichs zwischen den Streams verloren. Jedes Datenformat ist möglich.\n\n\nGantt chart\nAlternative Namen: Balkenplan\n\nWas stellt es dar: Ein Gantt chart zeigt eine zeitliche Abfolge von Ereignissen oder Terminen. Dabei wird der zeitliche Startpunkt und der Endpunkt des Ereignisses mittels eines horizontalen Balkens dargestellt sowie der Name des Ereignisses angegeben. Die Balkenlänge zeigt somit die Dauer des Ereignis an. Verschiedene Kategorien von Ereignissen können farblich unterschieden werden. Ein Gantt chart kann auch für Projektmanagement genutzt werden, wobei die „Ereignisse“ beispielsweise die Arbeitszeit von Mitarbeitenden repräsentieren.\nBeispiel hier: Das „Ereignis“ ist die Regierungszeit italienischer Präsident*innen und Ministerpräsident*innen.\nWelche Fehler sollten allgemein in Bezug auf diesen Diagrammtyp vermieden werden: Die Nutzung dieses Diagrammtyps ist dann sinnvoll, wenn ein zeitlicher Vergleich von Ereignissen und ihrer Dauer dargestellt werden soll. Liegen alle Ereignisse in demselben Zeitraum und haben eine ähnliche Dauer, sagt das Diagramm letzlich nichts aus.\nWas ist bei RAWGraphs zu diesem Diagrammtyp zu beachten: Das Start- und das Abschlussdatum müssen in einem Format vorliegen, das RAWGraphs als Datumsformat erkennt. Nach Hochladen der Datentabelle kann das Datumsformat noch nach Bedarf angepasst werden.\nIn der Rubrik “4. Customize” unter Chart können die Balken ab- oder aufsteigend nach ihrem Startdatum angeordnet werden.\nSo könnte eine geeignete Datentabelle aufgebaut sein: Folgendes ist ein vereinfachter Auszug zu dem in RAWGraphs benutzten Datensatz zu Italians Pms and Presidents:\n\n\n\n\n\n\n\n\n\nStartdatum des Ereignis / Start date\nAbschlussdatum des Ereignis / End date\nName des Ereignis / Politician\nKategorie des Ereignis / Rolle\n\n\n\n\n1946-07-14\n1947-02-02\nAlicide De Gasperi\nPrime minister\n\n\n1953-08-17\n1954-01-18\nGuiseppe Pella\nPrime minister\n\n\n1992-05-28\n1999-05-15\nOscar Luigi Scalfaro\nPresident\n\n\n1962-05-11\n1964-12-06\nAntonio Segni\nPresident\n\n\n2006-05-15\n2015-01-14\nGiorgio Napolitano\nPresident\n\n\n\nSo wäre eine Datentabelle für einen Gantt Chart in RAWGraphs ungeeignet: Das Start- und das Enddatum muss dasselbe Datumsformat aufweisen. Sind die Daten unterschiedlich angegeben, ist es nicht möglich einen Zeitverlauf korrekt darzustellen.\nWelche Variablen werden in RAWGraphs für diesen Diagrammtyp benötigt:\n\nStart Date*: Das Startdatum des Ereignisses im Datumsformat.\nEnd Date*: Das Abschlussdatum des Ereignisses im Datumsformat.\nGroups: Der Name des Ereignis. Hier ist nur die Wortform möglich.\nColor: Kategorien der Ereignisse. Hier ist nur die Wortform möglich."
  },
  {
    "objectID": "diagrammtypenrawgraphs.html#netzwerke",
    "href": "diagrammtypenrawgraphs.html#netzwerke",
    "title": "Diagrammtypen in RAWGraphs",
    "section": "Netzwerke",
    "text": "Netzwerke\n\nArc Diagram\nAlternative Namen: Bogendiagramm\n\nWas stellt es dar: Netzwerkbeziehungen zwischen Personen oder Objekten. Die beteiligten Personen/Objekte sind auf einer horizontalen Linie als Punkte aufgereiht. Die Größe der Punkte vermittelt einen Eindruck davon, wie oft die Person/das Objekt insgesamt mit anderen vernetzt ist. Die Vernetzung der einzelnen Personen/Objekte wird durch die grauen bogenförmigen Linien gezeigt. Je dicker diese Linie ist, desto stärker ist die Vernetzung zwischen diesen beiden Personen/Objekten.\nBeispiel hier: Game of Thrones Charaktere, Lannister vs. Starck (zu diesem Datensatz aus RAWGraphs liegen nicht viele Informationen vor, daher ist unklar, worin die „Stärke“ der Beziehung zwischen zwei Charakteren begründet liegt).\nWelche Fehler sollten allgemein in Bezug auf diesen Diagrammtyp vermieden werden: Will man darstellen, wie eng oder stark die Beziehung zwischen zwei Personen ist, muss man vorher definieren, was die „Stärke“ der Beziehung darstellt. Dies kann z.B. sein, dass die Personen gemeinsam auftreten, Briefkontakt pflegen etc. Diese „Stärke“ sollte empirisch messbar sein und nicht nur geschätzt werden.\nWas ist bei RAWGraphs zu diesem Diagrammtyp zu beachten: Die Beziehung zwischen zwei Personen oder Objekten wird in RAWGraphs immer aus einer bestimmten Richtung verstanden. Hat Person A eine Beziehung zu Person B, muss Person A in der ersten Tabellenspalte und Person B in der zweiten Tabellenspalte stehen. Wenn dann Person B auch in Beziehung mit einer Person C steht, ist es allerdings nicht möglich, Person B in die erste Tabellenspalte und Person C in die zweite Spalte zu stellen, da in der erstgenannten Beziehung Person B in der zweiten Spalte steht. Das heißt, eine Person kann immer nur in einer Spalte auftreten. Ansonsten erscheint diese Person mehrfach in der Visualisierung. Man erhält dann keinen guten Überblick über die verschiedenen Beziehungen, die diese Person pflegt.\nIn der Rubrik “4. Customize” unter Chart kann die Minimal- und Maximalgröße der Punkte, die die Personen/Objekte darstellen, verändert werden (Min diameter, Max diameter). Gleichzeitig kann die Größe der Punkt anhand verschiedener Kriterien bestimmt werden (Nodes diameter). Sie können alle auf dieselbe Größe gesetzt werden, sie können aber auch nach verschiedenen Berechnungen aus der Netzwerkanalyse in der Größe reguliert werden. Eine Einführung zu Berechnungen dieser Art findet sich in Jannidis, F. (2017). Netzwerke. In: Jannidis, F., Kohle, H., Rehbein, M. (eds) Digital Humanities. J.B. Metzler, Stuttgart. Die Anordnung der Personen/Objekte kann durch verschiedene Parameter bestimmt werden: Name, Größe, Anzahl der Verbindungen und passend nach dem besten Platzverhältnis im Gesamtdiagramm (Sort nodes by). Die Farbintensität der Bögen ist unter Links opacity einstellbar. Zudem kann bestimmt werden, ob die Bögen nur oberhalb der Punkte verlaufen sollen (Arcs only on the top).\nSo könnte eine geeignete Datentabelle aufgebaut sein: Es müssen mindestens zwei Spalten vorliegen: Die beiden Personen, die miteinander in Beziehung stehen, müssen in je eine Spalte eingetragen werden. Zusätzlich kann eine dritte Zahlenspalte eingetragen werden, die beschreibt, wie eng die Beziehung zwischen den beiden Personen ist (dies kann bei einem Theaterstück oder Roman beispielsweise sein, wie oft die beiden Personen zusammen auftreten und miteinander sprechen, in einem Briefnetzwerk kann es beispielsweise beschreiben, wie oft diese beiden Personen Nachrichten austauschen etc.)\nFolgendes ist ein vereinfachter Auszug zu dem in RAWGraphs benutzten Datensatz zu Lannister vs Starck relationships:\n\n\n\nPerson 1/Source\nPerson 2/Target\nStärke der Beziehung/Size\n\n\n\n\nArya Stark\nTyrion Lannister\n11\n\n\nArya Stark\nTywin Lannister\n13\n\n\nBran Stark\nCersei Lannister\n6\n\n\nCatelyn Stark\nStafford Lannister\n3\n\n\n\nSo wäre eine Datentabelle für ein Arc Diagram in RAWGraphs ungeeignet: Es stellt ein Problem dar, wenn ein- und dieselbe Person mal in der Source-Spalte und mal in der Target-Spalte eingetragen ist. Die Darstellung wird dadurch verfälscht. Personen können immer nur in einer der beiden Spalten auftreten.\n\n\n\nPerson 1/Source\nPerson 2/Target\nStärke der Beziehung/Size\n\n\n\n\nArya Stark\nTyrion Lannister\n11\n\n\nArya Stark\nTywin Lannister\n13\n\n\nBran Stark\nCersei Lannister\n6\n\n\nCatelyn Stark\nStafford Lannister\n3\n\n\nStafford Lannister\nArya Stark\n12\n\n\nTyrion Lannister\nCatelyn Stark\n6\n\n\n\nWelche Variablen werden in RAWGraphs für diesen Diagrammtyp benötigt:\n\nSource Node* und Target Node*: ist Pflichtfeld. Da nicht nur Beziehungen zwischen Personen dargestellt werden können, sondern auch zwischen Objekten, müssen diese beiden Variablen nicht zwangsweise Namen/Wörter sein, sondern können auch Zahlen oder Datumsangaben sein.\nSize: ist optional. Sie kann eingesetzt werden, wenn Informationen zur Stärke der Beziehung vorliegen."
  },
  {
    "objectID": "diagrammtypenrawgraphs.html#zusammenhang-zweier-werte",
    "href": "diagrammtypenrawgraphs.html#zusammenhang-zweier-werte",
    "title": "Diagrammtypen in RAWGraphs",
    "section": "Zusammenhang zweier Werte",
    "text": "Zusammenhang zweier Werte\n\nBubble chart\nAlternative Namen: Scatter Plot, Streudiagramm, Punktwolke\n\nWas stellt es dar: Die Abhängigkeit zweier Werte. Ein Wert wird auf der X-Achse des Diagramms, der andere Wert auf der Y-Achse des Diagramms definiert. Die Daten liegen als Wertepaare vor. Für jedes Wertepaar wird im Koordinatensystem ein Punkt gesetzt. Abhängig davon, ob die Wertepaare bestimmten Kategorien angehören, können die Punkte farbig markiert werden. Die Größe der Punkte kann abhängig von der Auswahl eines der Werte des Wertepaares festgelegt werden.\nBeispiel hier: Es wird der Zusammenhang zwischen den Kosten einer Filmproduktion und dem weltweiten Einspielergebnis dargestellt. Die Größe der Punkte wird durch das Einspielergebnis bestimmt. Die Farbe der Punkte ist durch das Genre des Films definiert. Betrachtet man beispielsweise die Action-Filme als blaue Punkte, sieht man, dass die Filmproduktion oft mit hohen Kosten verbunden ist, aber gleichzeitig auch das Einspielergebnis recht hoch ist.\nWelche Fehler sollten allgemein in Bezug auf diesen Diagrammtyp vermieden werden: Generell muss man sich darüber im Klaren sein, welche Werte man in Zusammenhang setzen möchte und ob dieser Vergleich sinnvoll ist. Prinzipiell kann jede Form von Wertepaar verglichen werden. Beispielsweise könnte man auch den Durchschnittspreis von Bleistiftarten mit dem Durchschnittspreis verschiedener Apfelsorten in Beziehung setzen und würde einen korrekt aufgebauten Bubble chart erhalten und vielleicht sogar Auffälligkeiten in der Verteilung der Wertepaare erkennen. Da man aber davon ausgehen kann, dass hier kein direkter Zusammenhang besteht, ist eine Auswertung dieser Art wenig sinnvoll und hat das Potenzial, zu wilden Theorien zu führen.\nDiesen Diagrammtyp zu wählen, macht auch nur dann Sinn, wenn die Daten einigermaßen gleichmäßig über einen Wertebereich verteilt sind. Liegen beispielsweise viele niedrige Werte und viele hohe Werte vor, während kaum Werte im Mittelbereich vorhanden sind, häufen sich die Punkte an einigen Stellen, was das Diagramm unübersichtlich machen kann.\nWas ist bei RAWGraphs zu diesem Diagrammtyp zu beachten: Prinzipiell bietet RAWGraphs die Möglichkeit, jeden einzelnen Datenpunkt mit einem Label zu versehen (in diesem Fall wäre dies der Name eines Films). Bei vielen Datenpunkten sind diese Labels aber letzten Endes kaum lesbar, da sie sich zu stark überlappen. Man muss daher abwägen, wie wichtig diese Beschriftung für die Diagrammdarstellung ist oder ob auf sie verzichtet werden kann.\nIn der Rubrik “4. Customize” unter Chart lässt sich zum einen die Größe der einzelnen Datenpunkte (Max diameter), zum anderen das Layout der Datenpunkte (Show stroke, Show dots on data values) anpassen. In dem Fall, wo alle Datenwerte einer Achse deutlich höher als null liegen, beginnt RAWGraphs automatisiert die Skala der Achse nicht bei null, sondern bei einem anderen, höheren Wert. Möchte man trotzdem die Achse bei null beginnen lassen, kann dies durch die Option “Set X origin to 0” bzw. “Set Y origin to 0” eingestellt werden.\nSo könnte eine geeignete Datentabelle aufgebaut sein: Folgendes ist ein vereinfachter Auszug zu dem in RAWGraphs benutzten Datensatz zu Highest grossing movies in history:\n\n\n\n\n\n\n\n\n\nWertepaar-Datenwert 1\nWertepaar-Datenwert2\nZugehörigkeit zu einer Gruppe für farbige Markierung der Punkte\n“Name” des Datenpunkts\n\n\n\n\n3.9\n402\nDrama\nGone with the wind\n\n\n237\n2790\nAction\nAvatar\n\n\n200\n2194\nDrama\nTitanic\n\n\n356\n2798\nAction\nAvengers: Endgame\n\n\n\nSo wäre eine Datentabelle für einen Bubble chart in RAWGraphs ungeeignet: Es ist vor allem darauf zu achten, dass die Wertepaare im Zahlenformat vorliegen, andere Datenformate sind hier nicht möglich.\nWelche Variablen werden in RAWGraphs für diesen Diagrammtyp benötigt:\n\nX-Axis*: ist Pflichtfeld, erster Datenwert des Wertepaars. Es muss ein Zahlen- oder Datumsformat sein.\nY-Axis*: ist Pflichtfeld, zweiter Datenwert des Wertepaars. Es muss ein Zahlen- oder Datumsformat sein.\nSize: Bestimmt die Größe der einzelnen Punkte und kann einer der Zahlenwerte des Wertepaares der X- oder Y-Achse sein. Liegen weitere Werte in der Datentabelle vor, kann die Größe der Punkte auch durch einen dritten Wert bestimmt werden. Der Wert muss im Zahlenformat vorliegen.\nColor: Die Punkte können farbig markiert werden. Dies ist dann sinnvoll, wenn die einzelnen Werte einer Gruppe zugeordnet werden können. Jedes Datenformat ist hier möglich.\nConnection By: (Bedeutung unklar)\nLabel: Name des Datenpunkts. Jedes Datenformat ist hier möglich."
  },
  {
    "objectID": "diagrammtypenrawgraphs.html#teilwerte-eines-ganzen",
    "href": "diagrammtypenrawgraphs.html#teilwerte-eines-ganzen",
    "title": "Diagrammtypen in RAWGraphs",
    "section": "Teilwerte eines Ganzen",
    "text": "Teilwerte eines Ganzen\n\nPie chart\nAlternative Namen: Kreisdiagramm, Kuchendiagramm, Tortendiagramm\n\nWas stellt es dar: Teilwerte (als Zahl oder Prozentanteil) eines Ganzen. Die Teilwerte werden als farbig unterschiedene „Kuchenstücke“ dargestellt. Im Fall einer Serie wird die Größe der einzelnen Kreise durch die Größe der Gesamtzahl bestimmt.\nBeispiel hier: Für jedes Land ist das Bruttoinlandsprodukt dargestellt, eingeteilt in die Sektoren Landwirtschaft, Industrie, Dienstleistung. Die Größe der Kreise zeigt beispielsweise, dass Deutschlands Bruttoinlandsprodukt niedriger ist als das Indiens.\nWelche Fehler sollten allgemein in Bezug auf diesen Diagrammtyp vermieden werden: Die Kreisform ist dazu gedacht, ein gesamtes Phänomen zu zeigen, und einen Eindruck von Gesamtheit vermitteln. Wenn man im oben genannten Beispiel nur Landwirtschaft und Industrie als Kreis darstellen würde, dann würde die Darstellung verfälscht sein, da der Eindruck entsteht, dass ein Bruttoinlandsprodukt nur aus diesen beiden Teilaspekten besteht. Würde man zwei Teilaspekte eines Gesamtphänomens einem direkten Vergleich unterziehen, würde sich hierfür ein Multi-set bar chart besser eignen.\nMehr als 7 oder 8 verschiedene „Kuchenstücke“ machen das Diagramm unübersichtlich. Liegen mehr Teilaspekte vor, sollte man auch hier alternativ auf andere Diagrammtypen ausweichen (z.B. die verschiedenen Arten von Balkendiagrammen).\nWas ist bei RAWGraphs zu diesem Diagrammtyp zu beachten: Die Werte für die einzelnen “Kuchenstücke” müssen im Zahlenformat vorliegen und dürfen keine Wörter oder Datumsangaben sein. Für jedes einzelne “Kuchenstück” muss nicht bereits eine Gesamtzahl vorliegen. Wenn einzelne Werte einem “Kuchenstück” zugeordnet werden können, werde diese automatisch von RAWGraphs summiert.\nIn der Rubrik “4. Customize” unter Chart lässt sich der Pie chart auch in einen “Donut chart” umwandeln, d.h. statt gefüllter “Kuchenstücke” liegt ein äußerer Ring vor, dessen Teilabschnitte farblich unterschieden werden.\nSo könnte eine geeignete Datentabelle aufgebaut sein: Siehe dazu beispielsweise den in RAWGraphs benutzten Beispieldatensatz GDP sector composition.\n\n\n\n\n\n\n\n\n\nTeilwerte als Zahlen von „Kuchenstück“ 1\nTeilwerte als Zahlen von „Kuchenstück“ 2\nTeilwerte als Zahlen von “Kuchenstück 3”\nHier könnten beispielsweise Ländernamen stehen oder andere Objekte. Diese werden in das Diagramm einbezogen, wenn man eine Serie erstellt\n\n\n\n\n15.4\n23.0\n61.5\nIndia\n\n\n1.1\n30.1\n68.7\nJapan\n\n\n0.7\n30.7\n68.6\nGermany\n\n\n\nSo wäre eine Datentabelle für einen Pie chart in RAWGraphs ungeeignet: Nicht jede Datentabelle ist für die Erstellung eines Pie chart geeignet, siehe dazu beispielsweise den in RAWGraphs zu findenden Datensatz zu Netflix Original Series 2013/2017. Hier ein Ausschnitt daraus:\n\n\n\nGenre\nTitle\nYear\n\n\n\n\nComedy\nMaster of None\n2015\n\n\nDrama\nBloodline\n2015\n\n\nDrama\nOrange Is the New Black\n2013\n\n\nComedy\nRussell Peters vs. the World\n2013\n\n\nDocu-Series\nMaking a Murderer\n2015\n\n\nComedy\nEasy\n2016\n\n\n\nWenn man mit einem Pie chart darstellen möchte, wie viele Filme zu einem Genre gehören (ein „Kuchenstück“ stellt dann jeweils ein Genre dar) oder wie viele Filme pro Jahr entstanden sind (ein „Kuchenstück“ steht dann jeweils für ein Jahr), ist dies in RAWGraphs mit dieser Tabelle nicht möglich. Die Werte müssten dann eigenhändig oder mit einem anderen Tool ausgezählt werden und die Tabelle in eine andere Form gebracht werden:\n\n\n\nComedy\nDrama\nDocu-Series\n\n\n\n\n3\n2\n1\n\n\n\n\n\n\n2013\n2015\n2016\n\n\n\n\n2\n3\n1\n\n\n\nWelche Variablen werden in RAWGraphs für diesen Diagrammtyp benötigt:\n\nArcs*: ist Pflichtfeld. Hier werden die Werte für die einzelnen „Kuchenstücke“ eingefügt. Es müssen Zahlenwerte sein. Dabei können beliebig viele Dimensionen genutzt werden, jedoch wird das Diagramm schnell unübersichtlich, wenn zu viele “Kuchenstücke” vorhanden sind.\nSeries: kann dann benutzt werden, wenn mehrere Pie charts nebeneinander erstellt werden müssen. Dies würde beispielsweise für verschiedene Länder oder verschiedene Jahre oder auch andere Parameter gelten. Hier ist jedes Datenformat möglich.\nDie Screenshots wurden von Theresa Blaschke und Lars Hadeler erstellt. Zuletzt bearbeitet am 14.11.2023"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DiCiHub",
    "section": "",
    "text": "Das Verbundprojekt DiCi-Hub, gefördert von der VW-Stiftung im Rahmen der Förderinitiative „Weltwissen – Strukturelle Stärkung kleiner Fächer“, stellt sich den Herausforderung von digitalen Tools und Methoden in der Film- und Medienwissenschaft. Das Projekt bringt drei Forschungsuniversitäten zusammen, um neue konzeptuelle Grundlagen und Methoden für das Fach zu entwickeln. Nachfolgend möchten wir einige unserer Projekte vorstellen:\n\n\n\n\n\n\nBrunch Lectures\n\n\n\n\n\n\n\nResearching Super 8\n\n\n\n\n\n\n\n\n\nTools und Tutorials\n\n\n\n\n\n\n\nKooperation mit media/rep/"
  },
  {
    "objectID": "index.html#dici-hub-digital-cinema-hub-a-research-hub-for-digital-film-studies",
    "href": "index.html#dici-hub-digital-cinema-hub-a-research-hub-for-digital-film-studies",
    "title": "DiCiHub",
    "section": "",
    "text": "Das Verbundprojekt DiCi-Hub, gefördert von der VW-Stiftung im Rahmen der Förderinitiative „Weltwissen – Strukturelle Stärkung kleiner Fächer“, stellt sich den Herausforderung von digitalen Tools und Methoden in der Film- und Medienwissenschaft. Das Projekt bringt drei Forschungsuniversitäten zusammen, um neue konzeptuelle Grundlagen und Methoden für das Fach zu entwickeln. Nachfolgend möchten wir einige unserer Projekte vorstellen:\n\n\n\n\n\n\nBrunch Lectures\n\n\n\n\n\n\n\nResearching Super 8\n\n\n\n\n\n\n\n\n\nTools und Tutorials\n\n\n\n\n\n\n\nKooperation mit media/rep/"
  },
  {
    "objectID": "researchingsuper8.html",
    "href": "researchingsuper8.html",
    "title": "Researching Super 8",
    "section": "",
    "text": "In Mainz, our research group is collaborating since 2021 with a group of collectors of Super 8 film material and related paratexts such as catalogs, magazines etc. Following a citizen-science principle we want to acknowledge how their experience, expertise and generosity has contributed to our own research.\nAndreas Chmielewski is a German collector of small-gauge films and in particular of Super8 format. He curates the website Super8rezensionen. This exists since 2000 and was first developed by Robert Weidemann. Main aim of the project is to describe and rate Super8 movies, to discuss the quality of the edit or of the color-copy of. Andreas has kindly borrowed us all his Super8 catalogs and allowed us to digitize them for further research.\nJoachim Schmidt is a German collector and the owner and curator of the website Off2.de a website dedicated to the history of Super8, which collects not only historical material and information about Super8 distribution in Germany but also features several video interviews (hosted on its youtube channel) with collectors, experts and ex-employees of Companies selling or working with Super8. Joachim was invited by our research group to present on Super8 history in Germany for an undergraduate course at the Film and Mediadramaturgy Institute in Mainz.\nEivind Mork (and his wife Heidi) developed in 2016 the website Super8database.com, which is a database and repository of Super8 movies distributed internationally in the past. The data is, if not stated otherwise, licenced by CC-BY 4.0. That’s a Creative Commons licence that allows us to work with the data in a way that meets our academic needs as long as we name Eivind Mork. A real advantage is that you can download the data in different file formats like Excel table or JSON, so that you can decide which format suits better. In our teaching and research we profited from the data collected and shared on Super8database.\nWe have reported on our collaboration at the NECS (Network for Cinema and Media Studies) Conference in Oslo in June 2023. Joachim and Eivind have published a short report on our presentations on their website. You can read it here:\nFrom Off2.de (in German)\nFrom Super8database.com (in English)"
  },
  {
    "objectID": "researchingsuper8.html#our-collaboration-with-collectors",
    "href": "researchingsuper8.html#our-collaboration-with-collectors",
    "title": "Researching Super 8",
    "section": "",
    "text": "In Mainz, our research group is collaborating since 2021 with a group of collectors of Super 8 film material and related paratexts such as catalogs, magazines etc. Following a citizen-science principle we want to acknowledge how their experience, expertise and generosity has contributed to our own research.\nAndreas Chmielewski is a German collector of small-gauge films and in particular of Super8 format. He curates the website Super8rezensionen. This exists since 2000 and was first developed by Robert Weidemann. Main aim of the project is to describe and rate Super8 movies, to discuss the quality of the edit or of the color-copy of. Andreas has kindly borrowed us all his Super8 catalogs and allowed us to digitize them for further research.\nJoachim Schmidt is a German collector and the owner and curator of the website Off2.de a website dedicated to the history of Super8, which collects not only historical material and information about Super8 distribution in Germany but also features several video interviews (hosted on its youtube channel) with collectors, experts and ex-employees of Companies selling or working with Super8. Joachim was invited by our research group to present on Super8 history in Germany for an undergraduate course at the Film and Mediadramaturgy Institute in Mainz.\nEivind Mork (and his wife Heidi) developed in 2016 the website Super8database.com, which is a database and repository of Super8 movies distributed internationally in the past. The data is, if not stated otherwise, licenced by CC-BY 4.0. That’s a Creative Commons licence that allows us to work with the data in a way that meets our academic needs as long as we name Eivind Mork. A real advantage is that you can download the data in different file formats like Excel table or JSON, so that you can decide which format suits better. In our teaching and research we profited from the data collected and shared on Super8database.\nWe have reported on our collaboration at the NECS (Network for Cinema and Media Studies) Conference in Oslo in June 2023. Joachim and Eivind have published a short report on our presentations on their website. You can read it here:\nFrom Off2.de (in German)\nFrom Super8database.com (in English)"
  },
  {
    "objectID": "texterkennung.html",
    "href": "texterkennung.html",
    "title": "How to: Computerbasierte Texterkennung",
    "section": "",
    "text": "Weitere Informationen folgen in Kürze\n\n\n\n\n Back to top"
  }
]