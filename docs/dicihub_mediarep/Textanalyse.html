<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Die Vermessung der medienwissenschaftlichen Welt?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../img/DiCi_Hub_transparent.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../brunchlectures.html" rel="" target="">
 <span class="menu-text">Brunch Lectures</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../researchingsuper8.html" rel="" target="">
 <span class="menu-text">Researching Super 8</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.uni-marburg.de/en/fb09/institutes/media-studies/research/research-projects/dici-hub" rel="" target="_blank">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Die Vermessung der medienwissenschaftlichen Welt?</li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Brunch Lectures</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../datensortieren.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Daten sortieren und filtern mit Excel</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../datenbereinigen.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Daten bereinigen und anreichern mit OpenRefine</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../datenvisualisieren.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Daten visualisieren mit RAWGraphs</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#datengestützte-analysen-mit-mediarep" id="toc-datengestützte-analysen-mit-mediarep" class="nav-link active" data-scroll-target="#datengestützte-analysen-mit-mediarep">Datengestützte Analysen mit media/rep/</a>
  <ul class="collapse">
  <li><a href="#inhalt" id="toc-inhalt" class="nav-link" data-scroll-target="#inhalt">Inhalt</a></li>
  </ul></li>
  <li><a href="#vorbedingungen" id="toc-vorbedingungen" class="nav-link" data-scroll-target="#vorbedingungen">Vorbedingungen </a><a class="anchor nav-link" id="prerequisites" data-scroll-target="undefined"></a></li>
  <li><a href="#textpreprocessing" id="toc-textpreprocessing" class="nav-link" data-scroll-target="#textpreprocessing">Textpreprocessing </a><a class="anchor nav-link" id="preprocessing" data-scroll-target="undefined"></a>
  <ul class="collapse">
  <li><a href="#eingrenzung-des-korpus" id="toc-eingrenzung-des-korpus" class="nav-link" data-scroll-target="#eingrenzung-des-korpus">Eingrenzung des Korpus </a><a class="anchor nav-link" id="eingrenzung" data-scroll-target="undefined"></a></li>
  <li><a href="#entfernen-von-stoppwörtern" id="toc-entfernen-von-stoppwörtern" class="nav-link" data-scroll-target="#entfernen-von-stoppwörtern">Entfernen von Stoppwörtern </a><a class="anchor nav-link" id="stoppwörter" data-scroll-target="undefined"></a></li>
  </ul></li>
  <li><a href="#textanalyse" id="toc-textanalyse" class="nav-link" data-scroll-target="#textanalyse">Textanalyse </a><a class="anchor nav-link" id="textanalyse" data-scroll-target="undefined"></a>
  <ul class="collapse">
  <li><a href="#suche-nach-vollständigen-wörtern-oder-wildcard-suche" id="toc-suche-nach-vollständigen-wörtern-oder-wildcard-suche" class="nav-link" data-scroll-target="#suche-nach-vollständigen-wörtern-oder-wildcard-suche">Suche nach vollständigen Wörtern oder Wildcard-Suche </a><a class="anchor nav-link" id="ganzewörter" data-scroll-target="undefined"></a></li>
  <li><a href="#identifizierung-von-verschiedenen-wortformen-und--kombinationen-einzelner-suchbegriffe-bei-einer-wildcard-suche" id="toc-identifizierung-von-verschiedenen-wortformen-und--kombinationen-einzelner-suchbegriffe-bei-einer-wildcard-suche" class="nav-link" data-scroll-target="#identifizierung-von-verschiedenen-wortformen-und--kombinationen-einzelner-suchbegriffe-bei-einer-wildcard-suche">Identifizierung von verschiedenen Wortformen und -kombinationen einzelner Suchbegriffe bei einer Wildcard-Suche </a><a class="anchor nav-link" id="wortformen" data-scroll-target="undefined"></a></li>
  <li><a href="#identifizierung-von-einzeltexten-die-einen-suchbegriff-enthalten" id="toc-identifizierung-von-einzeltexten-die-einen-suchbegriff-enthalten" class="nav-link" data-scroll-target="#identifizierung-von-einzeltexten-die-einen-suchbegriff-enthalten">Identifizierung von Einzeltexten, die einen Suchbegriff enthalten </a><a class="anchor nav-link" id="einzeltexte" data-scroll-target="undefined"></a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Die Vermessung der medienwissenschaftlichen Welt?</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="datengestützte-analysen-mit-mediarep" class="level2">
<h2 class="anchored" data-anchor-id="datengestützte-analysen-mit-mediarep">Datengestützte Analysen mit media/rep/</h2>
<p>Dieses Jupyter Notebook soll eine Grundlage bieten, die im Fachrepositorium media/rep/ vorhandenen Texte und die dazugehörigen Metadaten mithilfe eines Python-Skriptes zu analysieren. Hierzu werden Abschnitte für die Vorbereitung von Texten zur Analyse (Entfernung von Stoppwörtern, Neuzusammenstellung des Textkorpus, Gruppierung von Texten nach Jahreszahlen) sowie ein Durchsuchen der Texte nach konkreten Begriffen (als vollständige Wörter oder in Form einer Wildcard-Suche, Identifizierung von einzelnen Wortformen und -kombinationen bei einer Wildcard-Suche, Identifizierung von Einzeltexten, die einen Suchbegriff vermehrt enthalten) bereitgestellt. Funktional orientiert sich dieses Jupyter Notebook damit an Textanalysetools wie Voyant.</p>
<p>Generell eignet sich der bereit gestellte Code auch für die Analyse anderer Texte, die in demselben Format wie das media/rep/-Korpus vorliegen, wobei jedoch an einigen Stellen Anpassungen notwendig sein dürften.</p>
<p>Um das Notebook nutzen zu können, sind Grundkenntnisse in Python und im Umgang mit Jupyter Notebooks notwendig. Als ein Ergebnis aus der Zusammenarbeit von Medienwissenschaft und Digital Humanities ist das Notebook nicht daraufhin überarbeitet worden, eine möglichst hohe Performanz in der Umsetzung der Analyseschritte zu erreichen. Die Kommentierung der einzelnen Code-Abschnitte dient vor allem dazu, transparent zu machen, welche Schritte durchgeführt wurden, um die Analyseergebnisse zu erzielen.</p>
<section id="inhalt" class="level3">
<h3 class="anchored" data-anchor-id="inhalt">Inhalt</h3>
<ol type="1">
<li><a href="#prerequisites">Vorbedingungen</a></li>
<li><a href="#preprocessing">Textpreprocessing</a>
<ol type="a">
<li><a href="#eingrenzung">Eingrenzung des Korpus</a><br>
</li>
<li><a href="#gruppierung">Gruppierung von Texten nach Publikationsjahr</a><br>
</li>
<li><a href="#stoppwörter">Entfernen von Stoppwörtern</a><br>
</li>
</ol></li>
<li><a href="#textanalyse">Textanalyse</a>
<ol type="a">
<li><a href="#ganzewörter">Suche nach vollständigen Wörtern oder Wildcard-Suche</a><br>
</li>
<li><a href="#wortformen">Identifizierung von verschiedenen Wortformen und -kombinationen einzelner Suchbegriffe bei einer Wildcard-Suche</a><br>
</li>
<li><a href="#einzeltexte">Identifizierung von Einzeltexten, die einen Suchbegriff enthalten</a></li>
</ol></li>
</ol>
</section>
</section>
<section id="vorbedingungen" class="level2">
<h2 class="anchored" data-anchor-id="vorbedingungen">Vorbedingungen <a class="anchor" id="prerequisites"></a></h2>
<p>Die Analysegrundlage für dieses Jupyter Notebook stellen die im Fachrepositorium media/rep/ vorliegenden Publikationen dar. Diese können mithilfe eines Python-Skriptes im txt-Format heruntergeladen werden, wobei gleichzeitig eine Metadatentabelle generiert wird. Dieses Skript wird separat von diesem Jupyter Notebook zur Verfügung gestellt.</p>
<p>Für die Nutzung der in diesem Jupyter Notebook zur Verfügung gestellten Funktionalitäten ist es notwendig, die mittels des Skripts extrahierten txt-Dateien in einem Dateiordner zu speichern, der wiederum in einem übergeordneten Verzeichnis liegt, in der auch die bei Abruf der txt-Dateien automatisch gespeicherte Metadatentabelle sowie dieses Jupyter Notebook gespeichert werden. Hinzu kommt noch eine Stoppwortliste, die im Rahmen des Textpreprocessing verwendet wird und hier ebenfalls separat zur Verfügung gestellt wird. Diese vorgeschlagene Struktur gilt sowohl für die Nutzung des Jupyter Notebooks in einer IDE als auch einer Jupyter Umgebung. Die Ordnerstruktur sollte dementsprechend wie folgt aussehen:</p>
<p>Hauptverzeichnis<br>
– &gt; Dateiordner mit txt-Dateien<br>
——- &gt; 1988_….txt<br>
——- &gt; 2013_….txt<br>
——- &gt; …<br>
——- &gt; 2020_….txt<br>
– &gt; Metadatentabelle.csv<br>
– &gt; Jupyter Notebook.ipynb<br>
– &gt; Stoppwortliste.txt</p>
<p>Die Benennung der aus media/rep/ extrahierten txt-Dateien sollte grundsätzlich beibehalten werden, da einige Schritte des Textpreprocessings an die automatisch generierten Dateinamen angepasst sind. Die Benennung des Dateiordners mit den txt-Dateien sowie die Benennung der Metadatentabelle sind frei wählbar und werden an gekennzeichneten Stellen in diesem Jupyter Notebook abgefragt, um die Analyseschritte darauf durchführen zu können.</p>
<p>Generell empfiehlt es sich, eine Kopie der aus media/rep/ extrahierten Texte zu behalten, da durch das Textpreprocessing Inhalte verändert werden können. Um den Zustand der einzelnen Zwischenschritte des Preprocessing zu speichern, werden in den nachfolgenden Skripten automatisch neue Dateiordner generiert, in dem die bearbeiteten Dateien gespeichert werden.</p>
<p>Der in diesem Jupyter Notebook zur Verfügung gestellte Code wurde mit den Python-Versionen 3.8 - 3.11 getestet. Zur Nutzung aller Funktionalitäten des Notebooks ist die Installation und der Import folgender Libraries notwendig:</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Textbereinigung</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">#Einlesen der txt-Dateien</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> glob</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> shutil</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">#Erstellung von Dataframes und Berechnungen auf diesen</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">#Visualisierungen (Styling und Darstellung)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pygal </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pygal.style <span class="im">import</span> Style</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cairosvg</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> lxml</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tinycss2</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cssselect2</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co">#Wortwolken</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> wordcloud <span class="im">import</span> WordCloud</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Das Jupyter Notebook ist vom Prinzip her so aufgebaut, dass dem eigentlichen Skript jeweils eine Code-Zelle vorgelagert ist, in der beispielsweise Angaben zu dem Ordnernamen, der die zu analysierenden Dateien enthält, zu Suchbegriffen oder der Jahresrange der zu analysierenden Texte gemacht werden müssen.</p>
<p>Aufgrund der Größe des media/rep/-Textkorpus kann das Durchlaufen einer Code-Zelle je nach Bearbeitungsschritt bis zu 4 Minuten betragen.</p>
</section>
<section id="textpreprocessing" class="level2">
<h2 class="anchored" data-anchor-id="textpreprocessing">Textpreprocessing <a class="anchor" id="preprocessing"></a></h2>
<section id="eingrenzung-des-korpus" class="level3">
<h3 class="anchored" data-anchor-id="eingrenzung-des-korpus">Eingrenzung des Korpus <a class="anchor" id="eingrenzung"></a></h3>
<p>Das Herunterladen von txt-Dateien aus media/rep/ lässt sich bereits über das oben erwähnte Skript den Analysebedürfnissen entsprechend anpassen, indem nur bestimmte Teile des Korpus extrahiert bzw. nicht extrahiert werden. Aber auch nach Herunterladen des Gesamtkorpus besteht die Möglichkeit, dieses in kleinere Teil-Korpora zu zerlegen, um gezielt Analysen auf beispielsweise allen publizierten Rezensionen oder auf allen Ausgaben einer spezifischen Zeitschrift eines bestimmten Zeitraums durchzuführen. Dies kann durch Auswählen oder Ausschließen eines bestimmten Teils des Korpus geschehen. In dem eingangs erwähnten Artikel wurde für die Analyse beispielsweise die Publikationsform PeriodicalPart nicht mitberücksichtigt, da darin einige Publikations-Items vorliegen, die gleichzeitig als review oder article geführt werden und somit doppelt in die Analyse eingeflossen wären. Dies gilt vereinzelt auch für book und bookPart.</p>
<p>media/rep/ bietet unter anderem folgende Publikationsformen: review, article, PeriodicalPart, book, bookPart, workingPaper, doctoralThesis, report</p>
<p>Des Weiteren sind verschiedene Publikationsreihen - sowohl Buch als auch Zeitschrift - vorhanden, die über eine ISSN-Nummer identifiziert werden können. Beispielsweise ist die Zeitschrift ‘MEDIENwissenschaft: Rezensionen | Reviews’ mit der ‘issn:2196-4270’ verknüpft. Einen Überblick über die Publikationsreihen und ihre jeweiligen ISSN-Nummern bietet die beim Herunterladen der txt-Dateien automatisch generierte Metadatentabelle.</p>
<p>Als weitere Filtermöglichkeiten bietet sich zudem die Auswahl bestimmter Publikationsjahre oder Autor*innen an. Auch hierfür bietet die Metadatentabelle einen guten Überblick.</p>
<p>Um die nachfolgenden Schritte durchführen zu können, dürfen die Dateinamen der aus media/rep/ extrahierten Dateien nicht nachträglich verändert worden sein, sondern müssen in ihrem Originalzustand belassen werden. Dies gilt auch für die in der Metadatentabelle aufgeführten Dateinamen.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist der Name der aus media/rep/ gewonnenen Metadaten-Datei, </span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">die dann in einen Dataframe eingelesen wird.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>metadata <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. "metadata.csv"</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>df_metadata <span class="op">=</span> pd.read_csv(metadata, low_memory<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">Nachfolgend sind die verschiedenen Filteroptionen gelistet, </span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">die durch Entkommentieren ausgewählt werden können. </span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">Es besteht die Möglichkeit, Parameter auszuschließen (excluded) </span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">oder gezielt auszuwählen (included).</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">Die ausgewählten Parameter können in die jeweils leere Liste, </span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co">die .isin([ ]) folgt, eingetragen werden.</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">Für jede Filteroption wird ein Beispiel gezeigt.</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="co">Option 1: Filtern nach Erscheinungsjahr</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co">Wählt oder schließt die Publikationen aus, </span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co">die in den in der Liste eingetragenen Erscheinungsjahren publiziert wurden.</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co">Beispiel: </span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="co">years_excluded = df_metadata['dc.date.issued'].isin(["2012", "2013", "2014"]) == False </span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co">schließt alle Publikationen aus, die in den genannten Jahren publiziert wurden.</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="co">Das Erscheinungsjahr bezieht sich nicht auf die Publikation in media/rep/, </span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="co">sondern auf die Erstpublikation.</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="co">Die ersten drei Code-Zeilen müssen unverändert übernommen werden. </span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="co">Da die in media/rep/ enthaltenen Jahresangaben </span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="co">unterschiedlichen Formaten folgen, müssen diese angeglichen werden.</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="co">#years = df_metadata["dc.date.issued"].to_list()</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="co">#years = [i[:4] for i in years]</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="co">#df_metadata["dc.date.issued"] = years</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="co">#years_excluded = df_metadata['dc.date.issued'].isin([]) == False</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="co">#years_included = df_metadata['dc.date.issued'].isin([]) </span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a><span class="co">Option 2: Filtern nach Publikationsformat</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a><span class="co">Wählt oder schließt die Publikationen aus, </span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="co">die in den in der Liste eingetragenen Publikationsformaten publiziert wurden.</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a><span class="co">Beispiel: </span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a><span class="co">types_included = df_metadata['dc.type'].isin(["article", "PeriodicalPart"]) </span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a><span class="co">wählt alle Publikationen aus, </span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="co">die als article und PeriodicalPart publiziert wurden.</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a><span class="co">#types_excluded = df_metadata['dc.type'].isin([]) == False</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a><span class="co">#types_included = df_metadata['dc.type'].isin([])</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a><span class="co">Option 3:</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a><span class="co">Wählt oder schließt die Publikationen aus, </span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a><span class="co">die in den in der Liste eingetragenen Publikationsreihen publiziert wurden.</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a><span class="co">Beispiel: </span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a><span class="co">isPartof_excluded = df_metadata['dc.relation.isPartOf'].isin(["issn:2196-4270"]) == False </span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a><span class="co">schließt alle Publikationen der Zeitschrift "MEDIENwissenschaft: Rezensionen | Reviews" aus.</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a><span class="co">#isPartof_excluded = df_metadata['dc.relation.isPartOf'].isin([]) == False</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a><span class="co">#isPartof_included = df_metadata['dc.relation.isPartOf'].isin([])</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a><span class="co">Option 4:</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a><span class="co">Wählt oder schließt die Publikationen aus, </span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a><span class="co">die von bestimmten Autor*innen verfasst wurden.</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a><span class="co">Beispiel: </span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a><span class="co">creator_included = df_metadata['dc.creator'].isin(["Kessler, Frank"])</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a><span class="co">wählt nur Publikationen aus, </span></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a><span class="co">die von genanntem Autor verfasst wurden.</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a><span class="co">#creator_excluded = df_metadata['dc.creator'].isin([]) == False</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a><span class="co">#creator_included = df_metadata['dc.creator'].isin([])</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a><span class="co">Um mehrere Filteroptionen gemeinsam nutzen zu können, </span></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a><span class="co">müssen diese mit ihren oben genannten Variablennamen in der gewünschten </span></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a><span class="co">Reihenfolge des Filterns in die nachstehende Liste eingetragen werden.</span></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a><span class="co">Beispielsweise ließen sich somit zuerst alle article auswählen </span></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a><span class="co">und in einem zweiten Schritt die Auswahl auf bestimmte Jahre eingrenzen.</span></span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a><span class="co">Die einzelnen Variablen müssen dabei mit dem &amp; Zeichen verbunden werden.</span></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a><span class="bu">filter</span> <span class="op">=</span> <span class="co">#z.B. types_excluded &amp; years_excluded</span></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist der Name des Ordners, </span></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a><span class="co">in dem sich alle aus media/rep/ extrahierten Texte befinden.</span></span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>folder <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. "fulltext"</span></span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist der Name des Ordners, </span></span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a><span class="co">in dem die ausgewählten Dateien gespeichert werden sollen </span></span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a><span class="co">(dieser wird automatisch in diesem Verzeichnis generiert).</span></span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>filtered_folder <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. "filtered_corpus"</span></span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a>os.mkdir(filtered_folder)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">Der Dataframe wird nach den ausgewählten Optionen gefiltert.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>df_metadata_filtered <span class="op">=</span> df_metadata.loc[<span class="bu">filter</span>]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">Die Dateinamen aller übrig gebliebenen Einträge im Dataframe </span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">werden in eine Liste überführt.</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>filenames_list <span class="op">=</span> df_metadata_filtered[<span class="st">"fulltext_file"</span>].to_list()</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">Die Dateinamen in der Liste werden mit den Dateinamen </span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co">der im Ordner vorhandenen txt-Dateien abgeglichen.</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co">Wenn ein Dateiname im Ordner auf der Liste zu finden ist, </span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co">wird diese Datei in den neu erstellten Ordner kopiert, </span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co">der abschließend das neu erstellte Textkorpus enthält.</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> filename <span class="kw">in</span> os.listdir(folder):</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> filename <span class="kw">in</span> filenames_list:</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        full_file_path <span class="op">=</span> os.path.join(folder, filename)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        shutil.copy((os.path.join(folder, filename)), filtered_folder)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="gruppierung-von-texten-nach-publikationsjahr" class="level4">
<h4 class="anchored" data-anchor-id="gruppierung-von-texten-nach-publikationsjahr">Gruppierung von Texten nach Publikationsjahr <a class="anchor" id="gruppierung"></a></h4>
<p>Ein Gesamtabzug des media/rep/-Korpus besteht aus einer Menge von über 18.000 Texten (Stand Januar 2023). Abhängig von den jeweiligen Analysefragen können diese Texte separat betrachtet werden. Insbesondere für eine Visualisierung von Ergebnissen ist es jedoch notwendig, diese Dateien zu gruppieren. Hierzu bietet sich eine Gruppierung nach Publikationsjahr an. Hierbei ist nicht das Jahr der Publikation in media/rep/, sondern das Jahr der Erstpublikation relevant.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist der Name des Ordners, </span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">in dem sich alle aus media/rep/ extrahierten Texte befinden.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>folder <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. "fulltext"</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist der Name des Ordners, </span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">in dem die neu zusammengeführten Dateien gespeichert werden sollen </span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">(dieser wird automatisch in diesem Verzeichnis generiert).</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">Es ist sinnvoll, diese nach Jahreszahlen gruppierten txt-Dateien </span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">in einem separaten Ordner zu speichern, </span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">da diese ansonsten inmitten der zehntausenden Dateien </span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co">des bereits vorhandenen Ordners gespeichert würden </span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co">und manuell herausgesucht werden müssten.</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>year_folder <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. "fulltext_by_year"</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>os.mkdir(year_folder)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">Die vorhandenen Jahreszahlen werden </span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">aus den Dateinamen im gewählten Ordner extrahiert </span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">und in eine Liste überführt, </span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">wobei Duplikate entfernt </span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">und die Liste aufsteigend sortiert wird.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [year <span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> os.listdir(folder) <span class="cf">for</span> year <span class="kw">in</span> re.findall(<span class="st">"(\d</span><span class="sc">{4}</span><span class="st">)_"</span>, <span class="bu">file</span>)]</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> <span class="bu">list</span>(<span class="bu">dict</span>.fromkeys(years))</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>years.sort()</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co">Die txt-Dateien, die zusammengeführt werden sollen, </span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co">werden zusammen gemäß ihrem Publikationsjahr </span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co">aus dem enstprechenden Ordner eingelesen.</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> years:</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    files <span class="op">=</span> glob.glob(os.path.join(<span class="ss">f"</span><span class="sc">{</span>folder<span class="sc">}</span><span class="ss">"</span>, <span class="ss">f"</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">_*.txt"</span>))                   </span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Die nach Jahren eingelesenen Texte werden in dem neu erstellten Ordner</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="co">    als eine gemeinsame txt-Datei pro Jahr erstellt.</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(os.path.join(<span class="ss">f"</span><span class="sc">{</span>year_folder<span class="sc">}</span><span class="ss">"</span>, <span class="ss">f"</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">_fulltext.txt"</span>), <span class="st">"wb"</span>) <span class="im">as</span> outfile:</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> f <span class="kw">in</span> files:</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">with</span> <span class="bu">open</span>(f, <span class="st">"rb"</span>) <span class="im">as</span> infile:</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>                outfile.write(infile.read())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="entfernen-von-stoppwörtern" class="level3">
<h3 class="anchored" data-anchor-id="entfernen-von-stoppwörtern">Entfernen von Stoppwörtern <a class="anchor" id="stoppwörter"></a></h3>
<p>Um eine Textanalyse durchzuführen, bietet es sich an, vorab Stoppwörter zu entfernen, die für die Analyse nicht relevant sind (z.B. Präpositionen, Artikel, Füllwörter). Aufgrund der Größe des media/rep/-Korpus wird die inhaltliche Analyse der Texte durch das Entfernen von Stoppwörtern beschleunigt und erlaubt eine Fokussierung auf für das Textverständnis bedeutende Wörter. Dies ist insbesondere dann notwendig, wenn die inhaltliche Analyse das Ermitteln der häufigsten (semantisch bedeutsamen) Wörter beinhaltet. Im Rahmen der hier vorgestellten Analyse ist die Entfernung von Stoppwörtern zwar zu empfehlen, aber nicht zwingend erforderlich, da einer deduktiven Logik gefolgt und eine gezielte Suche nach Begriffen ermöglicht wird. Dies steht einem induktiven Ansatz gegenüber, bei dem durch Ermittlung von Worthäufigkeiten aller Wörter der Texte nach den häufigsten Begriffen gesucht wird. Letzteres stellt aufgrund der Größe des media/rep/-Korpus eine Herausforderung dar und erfordert eine zusätzliche Strategie, was den Umgang mit Stoppwörtern und der gemeinsamen Analyse verschiedener Wortformen angeht, und bietet sich somit für eine eigene Untersuchung an.</p>
<p>Zur Entfernung von Stoppwörtern kann auf eine im Kontext dieses Projektes erstellte Stoppwortliste zugegriffen werden, die auf der deutschen und englischen Stoppwortliste des Textanalysetools Voyant basiert und zusätzlich spezifisch dem media/rep/-Korpus angepasste Begriffe enthält.</p>
<p>Diese txt-Datei und somit die Auswahl und Anzahl der Stoppwörter kann je nach Bedarf angepasst werden. Vorraussetzung für die nachfolgenden Schritte ist, dass die Stoppwortliste in demselben Verzeichnis gespeichert ist wie dieses Jupyter Notebook.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist der Name der Stoppwortliste.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>stopword_list <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. "stopwords.txt"</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist der Name des Ordners, </span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">in dem sich alle aus media/rep/ extrahierten Texte befinden.</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>folder <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. "fulltext_by_year"</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist der Name des Ordners, </span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="co">in dem die nach Stoppwörtern gefilterten Dateien gespeichert werden sollen </span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="co">(dieser wird automatisch in diesem Verzeichnis generiert).</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>stopword_folder <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. "stopwordfiltered_by_year"</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>os.mkdir(stopword_folder)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">Einlesen der txt-Datei mit der Stoppworliste</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">und Überführen der Stoppwörter in eine Liste.</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(stopword_list, <span class="st">"r"</span>, encoding<span class="op">=</span><span class="st">"utf-8"</span>) <span class="im">as</span> infile1:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    stopwords <span class="op">=</span> [word.rstrip() <span class="cf">for</span> word <span class="kw">in</span> infile1]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">Jede im Dateiordner vorliegende txt-Datei </span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">wird nacheinander eingelesen </span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">und verschiedene Textbereinigungsschritte durchgeführt.</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> glob.glob(os.path.join(<span class="ss">f"</span><span class="sc">{</span>folder<span class="sc">}</span><span class="ss">"</span>, <span class="st">"*.txt"</span>)):</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(<span class="bu">file</span>, <span class="st">"r"</span>, encoding<span class="op">=</span><span class="st">"utf-8"</span>) <span class="im">as</span> infile2:</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        text_stop <span class="op">=</span> infile2.read()</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">        Am Ende einer Zeile durch Worttrennung </span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="co">        voneinander getrennte Wörter </span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="co">        werden zusammengeführt. </span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="co">        Zahlen, Zeilenumbrüche und Nicht-Wortzeichen </span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="co">        werden entfernt </span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="co">        und durch ein Leerzeichen ersetzt.</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        text_stop <span class="op">=</span> re.sub(<span class="st">"-</span><span class="ch">\n</span><span class="st">+|\d"</span>, <span class="st">""</span>, text_stop)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>        text_stop <span class="op">=</span> re.sub(<span class="st">"</span><span class="ch">\n</span><span class="st">|\W+"</span>, <span class="st">" "</span>, text_stop)</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="co">        Die Stoppwörter werden aus den Texten entfernt, </span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="co">        indem die Wörter eines Textes </span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="co">        jeweils von einem String in eine Liste überführt </span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a><span class="co">        und die Stoppwörter aus dieser Liste herausgefiltert werden. </span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="co">        Anschließend wird die übriggebliebene Wortliste </span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a><span class="co">        eines jeden Textes wieder in einen String überführt. </span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span> </span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>        text_stop <span class="op">=</span> <span class="st">' '</span>.join([word <span class="cf">for</span> word <span class="kw">in</span> text_stop.split() <span class="cf">if</span> word.lower() <span class="kw">not</span> <span class="kw">in</span> stopwords])</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a><span class="co">        Die Dateinamen der eingelesenen Texte </span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a><span class="co">        werden auf ihren Kernnamen reduziert </span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a><span class="co">        (Dateierweiterung, Dateipfad wird entfernt).</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>        filename <span class="op">=</span> Path(<span class="bu">file</span>).stem</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a><span class="co">        Die nach Stoppwörtern gefilterten Texte </span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a><span class="co">        werden in dem neu erstellten Ordner gespeichert.</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> <span class="bu">open</span>(os.path.join(<span class="ss">f"</span><span class="sc">{</span>stopword_folder<span class="sc">}</span><span class="ss">"</span>, <span class="ss">f"</span><span class="sc">{</span>filename<span class="sc">}</span><span class="ss">.txt"</span>), <span class="st">"w"</span>, encoding<span class="op">=</span><span class="st">"utf-8"</span>) <span class="im">as</span> outfile:</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>            output_text <span class="op">=</span> outfile.write(text_stop)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="textanalyse" class="level2">
<h2 class="anchored" data-anchor-id="textanalyse">Textanalyse <a class="anchor" id="textanalyse"></a></h2>
<p>Der folgende Abschnitt bezieht sich auf die Suche nach Wörtern in dem vorab erstellten Textkorpus und einer Visualisierung von Ergebnissen. Zum einen wird eine Suche nach vollständigen Wörtern bereitgestellt, zum anderen eine Wildcard-Suche, bei der lediglich der Anfang eines Wortes eingegeben werden muss und alle verschiedenen Endungsmöglichkeiten des Wortes in der Suche mitberücksichtigt werden. Die Ergebnisse werden in einen Dataframe überführt und können als csv-Datei gespeichert werden oder in Form eines Liniendiagramms betrachtet werden.</p>
<p>Um bei der Häufigkeitsanalyse die unterschiedliche Länge von Publikationen mitberücksichtigen zu können, werden relative statt absolute Zahlen in den Ergebnissen präsentiert. Dies bedeutet, dass die Häufigkeit des Vorkommens eines Suchbegriffes in einem Text in Relation zu der Gesamtzahl der Wörter eines Textes gesetzt wird. Abhängig davon, ob während des Textpreprocessing Stoppwörter aus den Texten entfernt wurden oder nicht, steht die ermittelte Anzahl der Wörter eines vorbearbeiteten Textes nicht in jedem Fall für die eigentliche Gesamtlänge eines Textes. Wurden die Stoppwörter vorab entfernt, sind die relativen Werte höher, als wenn sie in Bezug auf die Gesamtlänge eines unbereinigten Textes berechnet würden. Ein isoliert betrachteter Wert ist daher nicht aussagekräftig. Erst die Kontextualisierung und der Vergleich mit weiteren Werten lässt Schlussfolgerungen über die Häufigkeit der Suchbegriffe zu.</p>
<p>Um eine übersichtliche Ergebnismenge zu generieren, bedarf es insbesondere hier einer Gruppierung der ursprünglich mehr als 18.000 Texte aus media/rep/. Hierzu bietet sich die Gruppierung nach Jahren an, wobei insbesondere der Zeitraum zwischen 1980 und 2020 eine repräsentative Textbasis für die Analyse bietet.</p>
<section id="suche-nach-vollständigen-wörtern-oder-wildcard-suche" class="level3">
<h3 class="anchored" data-anchor-id="suche-nach-vollständigen-wörtern-oder-wildcard-suche">Suche nach vollständigen Wörtern oder Wildcard-Suche <a class="anchor" id="ganzewörter"></a></h3>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">In die Liste keywords können die Suchbegriffe eingefügt werden. </span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">Diese müssen kleingeschrieben werden.</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">Es besteht die Möglichkeit einen vollständigen Begriff einzugeben, </span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">der in exakt dieser Form gesucht wird. </span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">Beispiel: </span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">Der Suchbegriff "digital" würde nicht die Vorkommen von </span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">"digitale", "digitales" etc. berücksichtigen, </span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">sondern nur den Begriff exakt wie er geschrieben wird.</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">Es besteht aber auch die Möglichkeit </span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">nur die Anfangsbuchstaben eines Begriffes einzugeben, </span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">um verschiedene Wortformen und -kombinationen mitzuberücksichtigen </span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">Beispiel: </span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">Der Suchbegriff "digital" würde alle Wörter berücksichtigen, </span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co">bei denen "digital" den Beginn des Wortes darstellt: </span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co">"digitales", "digitalität", "digitalpakt" etc.</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co">Ob eine Suche nach vollständigen Wörtern </span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co">oder eine Wildcard-Suche gewünscht ist, </span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co">muss in der nachfolgenden Code-Zelle </span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="co">an der gekennzeichneten Stelle gewählt werden.</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co">Prinzipiell können so viele Suchbegriffe eingegeben werden, </span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="co">wie gewünscht ist. </span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="co">Zu viele Begriffe bedeuten jedoch auch eine größere Anzahl von Linien</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="co">im erstellten Diagramm, was zu Unübersichtlichkeit führen kann. </span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="co">Es ist daher empfehlenswert, maximal 6 Suchbegriffe zu wählen.</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>keywords <span class="op">=</span> [] <span class="co"># z.B. ["virtuell", "internet", "netz", "online", "interaktiv", "digital"]</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist der Name des Dateiordners, </span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a><span class="co">der die zu analysierenden txt-Dateien enthält.</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>folder <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. stopwordfiltered_by_year</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist die Range der untersuchten Texte als Index </span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a><span class="co">für den zu erstellenden Dataframe mit den Analyseergebnissen </span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a><span class="co">sowie für die Beschriftung der Visualisierung.</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a><span class="co">Dies ist abhängig von der untersuchten Textgrundlage. </span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a><span class="co">Sind die Texte beispielsweise nach Jahren gruppiert </span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a><span class="co">und stammen aus den Jahren 1980-2020 </span></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a><span class="co">ist die range(1980, 2021, 1) zu wählen </span></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a><span class="co">(zur Erklärung der range-Funktion siehe</span></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a><span class="co">https://docs.python.org/3/library/functions.html#func-range).</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>range_texts <span class="op">=</span> <span class="bu">range</span>(<span class="dv">1980</span>, <span class="dv">2021</span>, <span class="dv">1</span>)</span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist der Dateiname für die Speicherung der Ergebnisse als csv-Datei</span></span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>name_csv <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. "suche_digit_virtu"</span></span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist der Dateiname für die Speicherung der Ergebnisdiagramme (png, svg)</span></span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a>name_chart <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. "suche_digit_virtu"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>BITTE BEACHTEN: Für die Auswahl zwischen einer Suche nach vollständigen Wörtern und einer Wildcard-Suche müssen im folgenden Abschnitt an gekennzeichneter Stelle Code-Zeilen auskommentiert bzw. entkommentiert werden.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">Anlegen eines leeren Dataframe, </span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">um die Ergebnisse der Häufigkeitsermittlung darin festzuhalten.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>df_results <span class="op">=</span> pd.DataFrame()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">Anlegen einer leeren Liste, </span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">in der die Gesamtzahl der Wörter der einzelnen Texte gespeichert wird </span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co">(relevant für die Berechnung von relativen Häufigkeiten).</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>number_words <span class="op">=</span> []</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co">Anlegen eines Dictionary, </span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co">in dem die Suchbegriffe jeweils als key gespeichert werden </span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co">und als value eine leere Liste angelegt wird, </span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co">in der im Folgenden die Häufigkeit des Suchbegriffs </span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="co">in den einzelnen Texten eingefügt wird.</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>frequency_keywords <span class="op">=</span> {key:[] <span class="cf">for</span> key <span class="kw">in</span> keywords}</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="co">Jede im Dateiordner vorliegende Textdatei </span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="co">wird nacheinander eingelesen </span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="co">und die Texte zur besseren Vergleichbarkeit </span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a><span class="co">vollständig in Kleinbuchstaben umgewandelt.</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> glob.glob(os.path.join(<span class="ss">f"</span><span class="sc">{</span>folder<span class="sc">}</span><span class="ss">"</span>, <span class="st">"*.txt"</span>)):</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(<span class="bu">file</span>, <span class="st">"r"</span>, encoding<span class="op">=</span><span class="st">"utf-8"</span>) <span class="im">as</span> infile:</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>        fulltext <span class="op">=</span> infile.read().lower()</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a><span class="co">        Jeder Text wird von einem String in eine Wortliste umgewandelt, </span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a><span class="co">        wobei die Wörter an den Nicht-Wortzeichen gesplittet werden.</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>        fulltext_list <span class="op">=</span> re.split(<span class="st">"\W+"</span>, fulltext)</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a><span class="co">        Die Länge der jeweils erstellten Wortlisten gibt Auskunft über die Länge des Textes </span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a><span class="co">        und wird für jeden Text einer Liste hinzugefügt.</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>        number_words.append(<span class="bu">len</span>(fulltext_list))</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a><span class="co">        Erstellen eines Dictionary für jeden Text.</span></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a><span class="co">        Hierzu wird über die Wortliste eines jeden Textes iteriert </span></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a><span class="co">        und die gefundenen Suchbegriffe als keys dem Dictionary hinzugefügt. </span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a><span class="co">        Bei erstmaligem Vorkommen erhält der Suchbegriff 1 als value.</span></span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a><span class="co">        Taucht der Suchbegriff mehrfach im Text auf, </span></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a><span class="co">        wird der value für jedes Vorkommen hochgezählt.</span></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>        fulltext_dict <span class="op">=</span> {}</span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> fulltext_list:</span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="kw">in</span> fulltext_dict:</span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a>                    fulltext_dict[i] <span class="op">+=</span><span class="dv">1</span></span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a>                    fulltext_dict[i] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a><span class="co">        Aus den für die einzelnen Texte erstellen Dictionaries </span></span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a><span class="co">        werden nur die gesuchten Begriffe ausgewählt.</span></span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a><span class="co">        Die Anzahl des Vorkommens der einzelnen Suchbegriffe wird pro Text summiert. </span></span>
<span id="cb9-64"><a href="#cb9-64" aria-hidden="true" tabindex="-1"></a><span class="co">        Die summierten Ergebnisse werden in Form einer Liste </span></span>
<span id="cb9-65"><a href="#cb9-65" aria-hidden="true" tabindex="-1"></a><span class="co">        als value dem eingangs erstellten Dictionary hinzugefügt.</span></span>
<span id="cb9-66"><a href="#cb9-66" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb9-67"><a href="#cb9-67" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-68"><a href="#cb9-68" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb9-69"><a href="#cb9-69" aria-hidden="true" tabindex="-1"></a><span class="co">        EINE DER BEIDEN FOLGENDEN OPTIONEN WÄHLEN UND DIE ANDERE AUSKOMMENTIEREN:</span></span>
<span id="cb9-70"><a href="#cb9-70" aria-hidden="true" tabindex="-1"></a><span class="co">        OPTION 1: SUCHE NACH VOLLSTÄNDIGEN WÖRTERN</span></span>
<span id="cb9-71"><a href="#cb9-71" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb9-72"><a href="#cb9-72" aria-hidden="true" tabindex="-1"></a>        <span class="co"># for i in keywords:</span></span>
<span id="cb9-73"><a href="#cb9-73" aria-hidden="true" tabindex="-1"></a>        <span class="co">#     keywords_dict = {k: v for k, v in fulltext_dict.items() if k == i}</span></span>
<span id="cb9-74"><a href="#cb9-74" aria-hidden="true" tabindex="-1"></a>        <span class="co">#     frequency_keywords[i].append(sum(keywords_dict.values()))</span></span>
<span id="cb9-75"><a href="#cb9-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-76"><a href="#cb9-76" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb9-77"><a href="#cb9-77" aria-hidden="true" tabindex="-1"></a><span class="co">        OPTION 2: WILDCARD_SUCHE</span></span>
<span id="cb9-78"><a href="#cb9-78" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb9-79"><a href="#cb9-79" aria-hidden="true" tabindex="-1"></a>        <span class="co"># for i in keywords:</span></span>
<span id="cb9-80"><a href="#cb9-80" aria-hidden="true" tabindex="-1"></a>        <span class="co">#    keywords_dict = {k: v for k, v in fulltext_dict.items() if k.startswith(i)}</span></span>
<span id="cb9-81"><a href="#cb9-81" aria-hidden="true" tabindex="-1"></a>        <span class="co">#    frequency_keywords[i].append(sum(keywords_dict.values()))</span></span>
<span id="cb9-82"><a href="#cb9-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-83"><a href="#cb9-83" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-84"><a href="#cb9-84" aria-hidden="true" tabindex="-1"></a><span class="co">Die Ergebnisse aus dem Dictionary </span></span>
<span id="cb9-85"><a href="#cb9-85" aria-hidden="true" tabindex="-1"></a><span class="co">sowie die Anzahl der Wörter pro Text </span></span>
<span id="cb9-86"><a href="#cb9-86" aria-hidden="true" tabindex="-1"></a><span class="co">werden in den Dataframe eingefügt. </span></span>
<span id="cb9-87"><a href="#cb9-87" aria-hidden="true" tabindex="-1"></a><span class="co">Die eingangs definierte Text-Range </span></span>
<span id="cb9-88"><a href="#cb9-88" aria-hidden="true" tabindex="-1"></a><span class="co">dient als Index des Dataframe.</span></span>
<span id="cb9-89"><a href="#cb9-89" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-90"><a href="#cb9-90" aria-hidden="true" tabindex="-1"></a>df_results.index <span class="op">=</span> range_texts</span>
<span id="cb9-91"><a href="#cb9-91" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k,v <span class="kw">in</span> frequency_keywords.items():</span>
<span id="cb9-92"><a href="#cb9-92" aria-hidden="true" tabindex="-1"></a>   df_results[k] <span class="op">=</span> v</span>
<span id="cb9-93"><a href="#cb9-93" aria-hidden="true" tabindex="-1"></a>df_results[<span class="st">"words"</span>] <span class="op">=</span> number_words</span>
<span id="cb9-94"><a href="#cb9-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-95"><a href="#cb9-95" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-96"><a href="#cb9-96" aria-hidden="true" tabindex="-1"></a><span class="co">Um relative Werte zu erhalten, </span></span>
<span id="cb9-97"><a href="#cb9-97" aria-hidden="true" tabindex="-1"></a><span class="co">wird die Anzahl des Vorkommens der keywords </span></span>
<span id="cb9-98"><a href="#cb9-98" aria-hidden="true" tabindex="-1"></a><span class="co">durch die Gesamtzahl der Wörter eines Textes dividiert.</span></span>
<span id="cb9-99"><a href="#cb9-99" aria-hidden="true" tabindex="-1"></a><span class="co">Für eine intiuitivere Erfassung der entstandenen Werte </span></span>
<span id="cb9-100"><a href="#cb9-100" aria-hidden="true" tabindex="-1"></a><span class="co">wird das Ergebnis mit 1000 multipliziert, </span></span>
<span id="cb9-101"><a href="#cb9-101" aria-hidden="true" tabindex="-1"></a><span class="co">so dass damit die Häufigkeit des Vorkommens eines Suchbegriffs </span></span>
<span id="cb9-102"><a href="#cb9-102" aria-hidden="true" tabindex="-1"></a><span class="co">pro 1000 Wörter Text dargestellt werden kann.</span></span>
<span id="cb9-103"><a href="#cb9-103" aria-hidden="true" tabindex="-1"></a><span class="co">Die Kolumne mit der Gesamtzahl der Wörter eines Textes </span></span>
<span id="cb9-104"><a href="#cb9-104" aria-hidden="true" tabindex="-1"></a><span class="co">wird anschließend gelöscht, </span></span>
<span id="cb9-105"><a href="#cb9-105" aria-hidden="true" tabindex="-1"></a><span class="co">da sie für die Erstellung der Visualisierung irrelevant ist.</span></span>
<span id="cb9-106"><a href="#cb9-106" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-107"><a href="#cb9-107" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> column <span class="kw">in</span> df_results:</span>
<span id="cb9-108"><a href="#cb9-108" aria-hidden="true" tabindex="-1"></a>    df_results[column] <span class="op">=</span> df_results.loc[:,column].div(df_results.loc[:,<span class="st">"words"</span>], axis <span class="op">=</span> <span class="dv">0</span>) <span class="op">*</span> <span class="dv">1000</span></span>
<span id="cb9-109"><a href="#cb9-109" aria-hidden="true" tabindex="-1"></a>df_results <span class="op">=</span> df_results.drop([<span class="st">'words'</span>], axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb9-110"><a href="#cb9-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-111"><a href="#cb9-111" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-112"><a href="#cb9-112" aria-hidden="true" tabindex="-1"></a><span class="co">Speichern der Ergebnisse in einer csv-Datei</span></span>
<span id="cb9-113"><a href="#cb9-113" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-114"><a href="#cb9-114" aria-hidden="true" tabindex="-1"></a>df_results.to_csv(<span class="ss">f"</span><span class="sc">{</span>name_csv<span class="sc">}</span><span class="ss">.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Zusätzlich zur vorangehenden Code-Zelle kann die nachfolgende Code-Zelle ausgeführt werden, um die Ergebnisse in Form eines Liniendiagramms darzustellen oder zu speichern.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">Festlegen der Parameter für die Visualisierung </span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">(Farbe der Kurven, Schriftart und -größe für die Beschriftung des Diagramms, </span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">Strichstärke für Diagrammlinien)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>diagram_style <span class="op">=</span> Style(</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    colors<span class="op">=</span>(<span class="st">'#FF0000'</span>, <span class="st">'#00FF00'</span>, <span class="st">'#0000FF'</span>, <span class="st">'#8A2BE2'</span>, <span class="st">'#000000'</span>, <span class="st">'#FFCC33'</span>),</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    font_family<span class="op">=</span><span class="st">'googlefont:Anuphan'</span>,</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    title_font_size<span class="op">=</span><span class="dv">24</span>,</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    label_font_size<span class="op">=</span><span class="dv">13</span>,</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    major_label_font_size<span class="op">=</span><span class="dv">13</span>,</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    guide_stroke_dasharray<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    major_guide_stroke_dasharray<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="co">Erstellen eines Liniendiagramms aus den im Dataframe ermittelten Werten </span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co">(für den Hintergrund der kubischen Interpolation </span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="co">siehe https://de.wikipedia.org/wiki/Spline-Interpolation)</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>linechart_results <span class="op">=</span> pygal.Line(style <span class="op">=</span> diagram_style, x_label_rotation <span class="op">=</span> <span class="dv">60</span>, interpolate <span class="op">=</span> <span class="st">"cubic"</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>linechart_results.title <span class="op">=</span> <span class="st">"Häufigkeit des Vorkommens der analysierten Begriffe pro 1000 Wörter des Gesamttexts"</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>linechart_results.x_labels <span class="op">=</span> range_texts</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> column <span class="kw">in</span> df_results:</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    linechart_results.add(<span class="ss">f'</span><span class="sc">{</span>column<span class="sc">}</span><span class="ss">'</span>, df_results.loc[:,column])</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a><span class="co">Darstellen des Liniendiagramms</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>linechart_results</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a><span class="co">#Zum Speichern des erstellten Diagramms als svg oder png </span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a><span class="co">#können die nachfolgenden Code-Zeilen entkommentiert werden.</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a><span class="co">#linechart_results.render_to_file(f"{name_chart}.svg")</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a><span class="co">#linechart_results.render_to_png(f"{name_chart}.png")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="identifizierung-von-verschiedenen-wortformen-und--kombinationen-einzelner-suchbegriffe-bei-einer-wildcard-suche" class="level3">
<h3 class="anchored" data-anchor-id="identifizierung-von-verschiedenen-wortformen-und--kombinationen-einzelner-suchbegriffe-bei-einer-wildcard-suche">Identifizierung von verschiedenen Wortformen und -kombinationen einzelner Suchbegriffe bei einer Wildcard-Suche <a class="anchor" id="wortformen"></a></h3>
<p>Durch die oben beschriebene Wildcard-Suche wird nicht ersichtlich, welche Wortformen und -kombinationen für die einzelnen Suchbegriffe berücksichtigt werden. Das nachfolgende Skript soll die Möglichkeit bieten, diese einzelnen Formen zu identifizieren, um eine stärkere Transparenz über die Ergebnisse der Wortzählung zu erzielen. Hierzu ist immer nur ein Suchbegriff auf einmal einzugeben (keine Liste von Suchbegriffen).</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist das Suchwort, </span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">für das die ermittelten Einzelformen ausgegeben werden sollen. </span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">Beispiel:</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">Die Suche nach "postkol" würde die Anzahl an Einzelformen </span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">wie Postkolonialismus, postkolonialistisch, postkolonial wiedergeben.</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>keyword <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. "postkol"</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist der Name des Dateiordners, </span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co">der die zu analysierenden txt-Dateien enthält.</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>folder <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. stopwordfiltered_by_year</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">Anlegen einer leeren Liste, </span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">in der die im Weiteren erstellten Dictionaries gesammelt werden.</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>list_dict_keyword <span class="op">=</span> []</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">Jede im Dateiordner vorliegende txt-Datei wird nacheinander eingelesen</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">und die Texte zur besseren Vergleichbarkeit vollständig in Kleinbuchstaben umgewandelt.</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> glob.glob(os.path.join(<span class="ss">f"</span><span class="sc">{</span>folder<span class="sc">}</span><span class="ss">"</span>, <span class="st">"*.txt"</span>)):</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(<span class="bu">file</span>, <span class="st">"r"</span>, encoding<span class="op">=</span><span class="st">"utf-8"</span>) <span class="im">as</span> infile:</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        text_keyword <span class="op">=</span> infile.read().lower()</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co">        Jeder Text wird von einem String in eine Wortliste umgewandelt, </span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co">        wobei die Wörter an den Nicht-Wortzeichen gesplittet werden.</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        text_keyword_list <span class="op">=</span> re.split(<span class="st">"\W+"</span>, text_keyword)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a><span class="co">        Erstellen eines Dictionary für jeden Text.</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a><span class="co">        Hierzu wird über die Wortliste eines jeden Textes iteriert </span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a><span class="co">        und die gefundenen Suchbegriffe als keys dem Dictionary hinzugefügt.</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a><span class="co">        Bei erstmaligem Vorkommen erhält der Suchbegriff 1 als value.</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a><span class="co">        Taucht der Suchbegriff mehrfach im Text auf, </span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a><span class="co">        wird der value für jedes Vorkommen hochgezählt.</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>        keyword_dict <span class="op">=</span> {}</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> text_keyword_list:</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="kw">in</span> keyword_dict:</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>                    keyword_dict[i] <span class="op">+=</span><span class="dv">1</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>                    keyword_dict[i] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a><span class="co">        Aus den für die einzelnen Texte erstellen Dictionaries </span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a><span class="co">        werden nur die Wörter ausgewählt, </span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a><span class="co">        die mit dem als keyword ausgewählten Suchbegriff beginnen.</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>        keyword_dict <span class="op">=</span> {k: v <span class="cf">for</span> k, v <span class="kw">in</span> keyword_dict.items() <span class="cf">if</span> k.startswith(keyword)}</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a><span class="co">        Die für jeden Text entstandenen Dictionaries werden einer Liste hinzugefügt.</span></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>        list_dict_keyword.append(keyword_dict)</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a><span class="co">Die in der Liste gesammelten einzelnen Dictionaries </span></span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a><span class="co">werden gemäß ihres keys (=der gefundenen Wortform) </span></span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a><span class="co">in einem gemeinsamen Dictionary zusammengefügt, </span></span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a><span class="co">wobei die Anzahl des Vorkommens der Wortform (= value des Dictionaries) </span></span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a><span class="co">in den einzelnen Texten zuerst als Liste gespeichert wird.</span></span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>keyword_dict_complete <span class="op">=</span> {</span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true" tabindex="-1"></a>    k: [d.get(k) <span class="cf">for</span> d <span class="kw">in</span> list_dict_keyword <span class="cf">if</span> k <span class="kw">in</span> d]</span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">set</span>().union(<span class="op">*</span>list_dict_keyword)</span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb12-61"><a href="#cb12-61" aria-hidden="true" tabindex="-1"></a><span class="co">Die in den values des Dictionary als Liste gespeicherten </span></span>
<span id="cb12-62"><a href="#cb12-62" aria-hidden="true" tabindex="-1"></a><span class="co">Einzelwerte des Vorkommens der einzelnen Wortformen werden summiert.</span></span>
<span id="cb12-63"><a href="#cb12-63" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb12-64"><a href="#cb12-64" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k,v <span class="kw">in</span> keyword_dict_complete.items():</span>
<span id="cb12-65"><a href="#cb12-65" aria-hidden="true" tabindex="-1"></a>    keyword_dict_complete[k] <span class="op">=</span> <span class="bu">sum</span>(v)</span>
<span id="cb12-66"><a href="#cb12-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-67"><a href="#cb12-67" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb12-68"><a href="#cb12-68" aria-hidden="true" tabindex="-1"></a><span class="co">Das Dictionary wird absteigend nach der Höhe der values sortiert </span></span>
<span id="cb12-69"><a href="#cb12-69" aria-hidden="true" tabindex="-1"></a><span class="co">(die häufigst vorkommenden Wortformen werden an den Anfang gestellt).</span></span>
<span id="cb12-70"><a href="#cb12-70" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb12-71"><a href="#cb12-71" aria-hidden="true" tabindex="-1"></a>keyword_dict_complete <span class="op">=</span> {k: v <span class="cf">for</span> k, v <span class="kw">in</span> <span class="bu">sorted</span>(keyword_dict_complete.items(), key<span class="op">=</span><span class="kw">lambda</span> item: item[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)}</span>
<span id="cb12-72"><a href="#cb12-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-73"><a href="#cb12-73" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb12-74"><a href="#cb12-74" aria-hidden="true" tabindex="-1"></a><span class="co">Das Dictionary wird in einen Dataframe überführt </span></span>
<span id="cb12-75"><a href="#cb12-75" aria-hidden="true" tabindex="-1"></a><span class="co">und das Ergebnis abschließend in einer csv-Datei gespeichert.</span></span>
<span id="cb12-76"><a href="#cb12-76" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb12-77"><a href="#cb12-77" aria-hidden="true" tabindex="-1"></a>df_keyword <span class="op">=</span> pd.DataFrame.from_dict(keyword_dict_complete, orient<span class="op">=</span><span class="st">'index'</span>, columns<span class="op">=</span>[<span class="st">"Häufigkeit"</span>])</span>
<span id="cb12-78"><a href="#cb12-78" aria-hidden="true" tabindex="-1"></a>df_keyword.to_csv(<span class="ss">f"</span><span class="sc">{</span>keyword<span class="sc">}</span><span class="ss">_einzelformen.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Das Ergebnis dieser Analyse lässt sich auch durch Nutzung des Ergebnis-Dictionary keyword_dict_complete und der Python-Library WordCloud in einer Wortwolke darstellen. Für die Funktionalitäten von WordCloud siehe auch https://www.python-lernen.de/wordcloud-erstellen-python.htm. Generell bietet sich diese Form der Visualisierung für verschiedene hier durchgeführte Textanalyseschritte an.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">''' </span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">Erstellen der WordCloud und Speichern als png</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>wc <span class="op">=</span> WordCloud(width<span class="op">=</span><span class="dv">800</span>, height<span class="op">=</span><span class="dv">400</span>, background_color<span class="op">=</span><span class="st">'white'</span>).generate_from_frequencies(keyword_dict_complete)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">5</span>))</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(wc, interpolation<span class="op">=</span><span class="st">'bilinear'</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="ss">f"</span><span class="sc">{</span>keyword<span class="sc">}</span><span class="ss">_wortwolke.png"</span>, facecolor<span class="op">=</span><span class="st">'k'</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="identifizierung-von-einzeltexten-die-einen-suchbegriff-enthalten" class="level3">
<h3 class="anchored" data-anchor-id="identifizierung-von-einzeltexten-die-einen-suchbegriff-enthalten">Identifizierung von Einzeltexten, die einen Suchbegriff enthalten <a class="anchor" id="einzeltexte"></a></h3>
<p>Das nachfolgende Skript soll die Möglichkeit bieten, die Anzahl und die Namen von Einzeltexten herauszufiltern, die einen bestimmten Suchbegriff enthalten. Während die vorangehenden Analyseschritte darauf basieren, dass die Texte nach Jahren gruppiert werden, um eine sinnvolle Auswertung zu ermöglichen, muss das nachfolgende Skript auf den aus media/rep/ extrahierten Einzeltexten ausgeführt werden. Hierzu ist prinzipiell keine Vorbearbeitung der Texte notwendig, es muss jedoch mit einer längeren Durchlaufzeit des Skriptes gerechnet werden (ca. 4-6 Minuten). Möchte man die Durchlaufzeit des Skriptes beschleunigen, kann das oben beschriebene Filtern von Stoppwörtern auch auf den Einzeldateien durchgeführt werden, was allerdings ebenfalls einen gewissen Zeitaufwand mit sich bringt.</p>
<p>Die nachfolgende Analyse stützt sich auf absolute im Gegensatz zu relativen Zahlen. Dies bedeutet, dass die Häufigkeit des Vorkommens des Suchbegriffes in einem Text nicht in Bezug zur Gesamtanzahl der Wörter des Textes gesetzt wird. Die Nutzung des Skriptes bietet sich an, wenn man gezielt nach Publikationen zu einem bestimmten Begriff sucht.</p>
<p>Das Skript sieht die Suche nach einem einzelnen Begriff vor und nicht die Suche nach mehreren Begriffen auf einmal. Hierzu müsste das Skript mehrmals hintereinander mit jeweils einem neuen Suchbegriff durchlaufen werden.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co">Eingabe des Suchbegriffes, </span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">für den das Vorkommen in Einzeltexten ermittelt wird.</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co">Mit dieser Suche kann nicht nur nach vollständigen Wörtern gesucht werden. </span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">Es werden auch Wörter wiedergegeben, </span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">die mit dem eingegegeben Suchbegriff beginnen, </span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co">aber unterschiedliche Endungen aufweisen </span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">Beispiel:</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">Für "digital" wird auch "digitalität", "digitales", "digitally" wiedergegeben.</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span> </span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>keyword_singletexts <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. "virtuell"</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="co">Einzufügen ist der Name des Dateiordners, </span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="co">der die zu analysierenden txt-Dateien enthält. </span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="co">In diesem Ordner müssen die aus media/rep/ extrahierten Einzeldateien vorliegen</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="co">und keine nach Jahren gruppierten Texten.</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>folder <span class="op">=</span> <span class="st">""</span> <span class="co">#z.B. "fulltext"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co">Anlegen eines leeren Dataframe, </span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">um die Ergebnisse der Häufigkeitsermittlung festzuhalten.</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>df_singletexts <span class="op">=</span> pd.DataFrame()</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">Anlegen einer leeren Liste, </span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="co">in der die Namen der Einzeltexte gespeichert werden, </span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co">die als Index des erstellten Dataframe fungieren.</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>filename_singletexts_list <span class="op">=</span>  []</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="co">Anlegen einer leeren Liste, </span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="co">in der die im Weiteren erstellten Dictionaries gesammelt werden.</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>list_singletexts_keyword <span class="op">=</span> []</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="co">Jede im Dateiordner vorliegende txt-Datei wird nacheinander eingelesen </span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a><span class="co">und die Texte zur besseren Vergleichbarkeit </span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span class="co">vollständig in Kleinbuchstaben umgewandelt.</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> glob.glob(os.path.join(<span class="ss">f"</span><span class="sc">{</span>folder<span class="sc">}</span><span class="ss">"</span>, <span class="st">"*.txt"</span>)):</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(<span class="bu">file</span>, <span class="st">"r"</span>, encoding<span class="op">=</span><span class="st">"utf-8"</span>) <span class="im">as</span> infile:</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>        text_singletexts <span class="op">=</span> infile.read().lower()</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a><span class="co">        Jeder Text wird von einem String in eine Wortliste umgewandelt, </span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a><span class="co">        wobei die Wörter an den Nicht-Wortzeichen gesplittet werden.</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>        text_singletexts_list <span class="op">=</span> re.split(<span class="st">"\W+"</span>, text_singletexts)</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a><span class="co">        Die Dateinamen der eingelesenen Texte </span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a><span class="co">        werden auf ihren Kernnamen reduziert </span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a><span class="co">        (Dateierweiterung, Dateipfad wird entfernt) </span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a><span class="co">        und in einer Liste gesammelt, </span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a><span class="co">        die im Weiteren den Index des Dataframes darstellt.</span></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>        filename_singletexts <span class="op">=</span> Path(<span class="bu">file</span>).stem</span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>        filename_singletexts_list.append(filename_singletexts)</span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a><span class="co">        Erstellen eines Dictionary für jeden Text.</span></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a><span class="co">        Hierzu wird über die Wortliste eines jeden Textes iteriert </span></span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a><span class="co">        und die gefundenen Suchbegriffe als keys dem Dictionary hinzugefügt.</span></span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a><span class="co">        Bei erstmaligem Vorkommen erhält der Suchbegriff 1 als value.</span></span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a><span class="co">        Taucht der Suchbegriff mehrfach im Text auf, </span></span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a><span class="co">        wird der value für jedes Vorkommen hochgezählt.</span></span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a>        singletexts_dict <span class="op">=</span> {}</span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> text_singletexts_list:</span>
<span id="cb15-55"><a href="#cb15-55" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="kw">in</span> singletexts_dict:</span>
<span id="cb15-56"><a href="#cb15-56" aria-hidden="true" tabindex="-1"></a>                    singletexts_dict[i] <span class="op">+=</span><span class="dv">1</span></span>
<span id="cb15-57"><a href="#cb15-57" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb15-58"><a href="#cb15-58" aria-hidden="true" tabindex="-1"></a>                    singletexts_dict[i] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb15-59"><a href="#cb15-59" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-60"><a href="#cb15-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb15-61"><a href="#cb15-61" aria-hidden="true" tabindex="-1"></a><span class="co">        Aus den für die einzelnen Texte erstellen Dictionaries </span></span>
<span id="cb15-62"><a href="#cb15-62" aria-hidden="true" tabindex="-1"></a><span class="co">        werden nur die Wörter ausgewählt, </span></span>
<span id="cb15-63"><a href="#cb15-63" aria-hidden="true" tabindex="-1"></a><span class="co">        die mit den als keywords eingetragenen Suchbegriffen beginnen.</span></span>
<span id="cb15-64"><a href="#cb15-64" aria-hidden="true" tabindex="-1"></a><span class="co">        Die Anzahl des Vorkommens der einzelnen Wortformen und -kombinationen </span></span>
<span id="cb15-65"><a href="#cb15-65" aria-hidden="true" tabindex="-1"></a><span class="co">        zu einem Suchbegriff wird addiert. </span></span>
<span id="cb15-66"><a href="#cb15-66" aria-hidden="true" tabindex="-1"></a><span class="co">        Das Ergebnis wird einer Liste hinzugefügt.</span></span>
<span id="cb15-67"><a href="#cb15-67" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb15-68"><a href="#cb15-68" aria-hidden="true" tabindex="-1"></a>        keyword_singletexts_dict <span class="op">=</span> {k: v <span class="cf">for</span> k, v <span class="kw">in</span> singletexts_dict.items() <span class="cf">if</span> k.startswith(keyword_singletexts)}</span>
<span id="cb15-69"><a href="#cb15-69" aria-hidden="true" tabindex="-1"></a>        list_singletexts_keyword.append(<span class="bu">sum</span>(keyword_singletexts_dict.values()))</span>
<span id="cb15-70"><a href="#cb15-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-71"><a href="#cb15-71" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-72"><a href="#cb15-72" aria-hidden="true" tabindex="-1"></a><span class="co">Die Ergebnisse aus dem Dictionary sowie die Anzahl der Wörter pro Text </span></span>
<span id="cb15-73"><a href="#cb15-73" aria-hidden="true" tabindex="-1"></a><span class="co">werden in den Dataframe eingefügt.</span></span>
<span id="cb15-74"><a href="#cb15-74" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-75"><a href="#cb15-75" aria-hidden="true" tabindex="-1"></a>df_singletexts.index <span class="op">=</span> filename_singletexts_list</span>
<span id="cb15-76"><a href="#cb15-76" aria-hidden="true" tabindex="-1"></a>df_singletexts[keyword_singletexts] <span class="op">=</span> list_singletexts_keyword</span>
<span id="cb15-77"><a href="#cb15-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-78"><a href="#cb15-78" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-79"><a href="#cb15-79" aria-hidden="true" tabindex="-1"></a><span class="co">Ausgabe der Anzahl der Texte des Gesamtkorpus, </span></span>
<span id="cb15-80"><a href="#cb15-80" aria-hidden="true" tabindex="-1"></a><span class="co">die den Suchbegriff enthalten, sowie den Prozentanteil, </span></span>
<span id="cb15-81"><a href="#cb15-81" aria-hidden="true" tabindex="-1"></a><span class="co">den diese Texte vom Gesamtkorpus ausmachen.</span></span>
<span id="cb15-82"><a href="#cb15-82" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-83"><a href="#cb15-83" aria-hidden="true" tabindex="-1"></a>text_with_content <span class="op">=</span> <span class="bu">len</span>(list_singletexts_keyword) <span class="op">-</span> list_singletexts_keyword.count(<span class="dv">0</span>)</span>
<span id="cb15-84"><a href="#cb15-84" aria-hidden="true" tabindex="-1"></a>percent_content <span class="op">=</span> <span class="bu">round</span>(text_with_content <span class="op">/</span> <span class="bu">len</span>(list_singletexts_keyword) <span class="op">*</span> <span class="dv">100</span>, <span class="dv">2</span>)</span>
<span id="cb15-85"><a href="#cb15-85" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Anzahl der Texte, die den Suchbegriff '</span><span class="sc">{</span>keyword_singletexts<span class="sc">}</span><span class="ss">' enthalten: </span><span class="sc">{</span>text_with_content<span class="sc">}</span><span class="ss"> (in Prozent: </span><span class="sc">{</span>percent_content<span class="sc">}</span><span class="ss">%) </span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb15-86"><a href="#cb15-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-87"><a href="#cb15-87" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-88"><a href="#cb15-88" aria-hidden="true" tabindex="-1"></a><span class="co">Gibt die 10 häufigsten Textnamen </span></span>
<span id="cb15-89"><a href="#cb15-89" aria-hidden="true" tabindex="-1"></a><span class="co">und die Häufigkeit der Nennung in absoluten Zahlen der Texte aus, </span></span>
<span id="cb15-90"><a href="#cb15-90" aria-hidden="true" tabindex="-1"></a><span class="co">die den Suchbegriff am häufigsten enthalten</span></span>
<span id="cb15-91"><a href="#cb15-91" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb15-92"><a href="#cb15-92" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Nachfolgend sind die 10 Texte gelistet, in denen der Suchbegriff '</span><span class="sc">{</span>keyword_singletexts<span class="sc">}</span><span class="ss">' in absoluten Zahlen am häufigsten vorkommt: </span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb15-93"><a href="#cb15-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-94"><a href="#cb15-94" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df_singletexts[keyword_singletexts].nlargest(<span class="dv">10</span>).to_string())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          // default icon
          link.classList.add("external");
      }
    }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">© 2023 <a href="https://www.uni-marburg.de/en/fb09/institutes/media-studies/research/research-projects/dici-hub">Digital Cinema Hub</a>, Marburg - Mainz - Frankfurt. <br> Für die Inhalte externer Seiten übernehmen wir trotz sorgfältiger Überprüfung keine Verantwortung.</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>



</body></html>